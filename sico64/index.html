<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>SICO - The Single Instruction Computer</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script src="../style/style.js"></script>
	<script src="./sico.js"></script>
	<script src="./editor.js"></script>
</head>
<body>
<!--
TODO:

explain as a series of subtractions, then add jumping.

-->

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's General Site</a></div>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ Online Interpreter ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>SICO Online Editor</h1>
	<div style="text-align:center;">
		<button id="sico_run">&#9654;&nbsp;&nbsp;&nbsp;Run</button>
		<button id="sico_reset">&#8634;&nbsp;&nbsp;&nbsp;Reset</button>
		<button id="sico_advanced">&#9776;&nbsp;&nbsp;&nbsp;Advanced</button>
		<label>Demos:
			<select id="sico_demo">
				<option value="./libraries/hello_demo.sico">Hello World</option>
				<option value="./libraries/string_demo.sico">String Printing</option>
				<option value="./libraries/uint_demo.sico">Unsigned Math</option>
				<option value="./libraries/random_demo.sico">Random Numbers</option>
				<option value="./libraries/memory_demo.sico">Memory</option>
				<option value="">Blank</option>
			</select>
		</label>
	</div>
	<div id="sico_menu" class="codeblock" style="box-sizing:border-box;width:100%;display:none;font-family:sans-serif;white-space:normal;">
		<p>Advanced Settings</p><br>
		<input type="checkbox" id="sico_keyboard" checked>
		<label for="sico_keyboard"> Grab Keyboard:<br>
			<br>
			<span style="padding-left:2rem;">&bull;</span> Enables tab key<br>
			<span style="padding-left:2rem;">&bull;</span> F9: run<br>
			<span style="padding-left:2rem;">&bull;</span> F10: reset<br>
			<span style="padding-left:2rem;">&bull;</span> F11: release keyboard
		</label>
	</div>
	<canvas id="sico_canvas" style="display:none;background:#000000;width:100%;margin-top:1rem"></canvas>
	<textarea id="sico_output" style="box-sizing:border-box;width:100%;height:14rem;" class="consoleblock" spellcheck="false" readonly>Please enable javascript to run</textarea>
	<textarea id="sico_editor" style="box-sizing:border-box;width:100%;height:40rem;" class="codeblock" spellcheck="false">#|==============================================================================


Unsigned Integer Testing - v1.08

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


average instructions per function
cmp: 28
min: 33
max: 33
set: 24
neg: 25
add: 30
sub: 31
mul: 707
div: 87
shl: 139
shr: 112
not: 26
and: 469
 or: 470
xor: 471


|#


0 0 test.main


test.main:
	# Unsigned integer tests.
	0 ? string.print 'u 'n 's 'i 'g 'n 'e 'd '  'i 'n 't 'e 'g 'e 'r '  't 'e 's 't 's 10 0

	# ------------------------ Timing ------------------------
	.time .time ?+1
	.time 0-5   ?+1

	# ------------------------- Bits -------------------------
	# Calculate how many bits we're using. Set [hbit]=1&lt;&lt;(bits-1).
	.tmp0     .z-1   ?+1
	.bitloop:
	.tmp0     .z     .bitdone
	.hbit     .hbit  ?+1
	.hbit     .tmp0  ?+1
	.tmp0     .hbit  ?+1
	.bits     .z-1   .bitloop
	.bitdone:

	# Set other bit related values.
	.nbits    .bits  ?+1
	.nbits-1  .bits  ?+1
	.bits+1   .nbits ?+1
	.bits+2   .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftsub .nbits ?+1
	.shiftsub .z-2   ?+1

	0 ? string.print 'b 'i 't 's ': '  string.uint .bits 10 0

.loop:
	# While trial&lt;trials.
	.tmp0 .tmp0 ?+1
	.tmp0 .trials ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	.tmp1 .trial .done

	# ---------------------- Parameters ----------------------
	# Generate A, B, and C parameters.
	0 ? test.rand.uint .a
	0 ? test.rand.uint .b
	0 ? random.mod     .c .shiftmax
	.c .shiftsub ?+1

	# Randomly set A=B.
	0 ? random.mod     .tmp0 .eqprob
	.tmp0 .z    ?+4
	.tmp0 .tmp0 .nosetab
	.tmp0 .b    ?+1
	.a    .a    ?+1
	.a    .tmp0 ?+1
	.nosetab:

	# Copy A, B, and C to compare later.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.a0   .a0   ?+1
	.a0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.b0   .b0   ?+1
	.b0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .c    ?+1
	.c0   .c0   ?+1
	.c0   .tmp0 ?+1

	# 0 ? string.print string.uint .trial '  string.uint .a '  string.uint .b ' 
	#                  string.uint .c 10 0

	# ----------------------- Compare ------------------------
	# Compare A and B manually.
	.exp0 .exp0 ?+1
	.exp0 .z-1  ?+1
	.b    .a    ?+4
	.exp0 .z+1  ?+7
	.b    .z    ?+4
	.exp0 .z-1  ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.b    .tmp0 ?+1

	.ret0 .ret0 ?+1
	0 ? test.measure .cmpops .cmplt 0 ? uint.cmp .a .b .cmplt .cmpeq .cmpgt
	0-1 0 ?-2
	.cmpgt: .ret0   .z-1  ?+1
	.cmpeq: .ret0   .z-1  ?+1
	.cmplt: .cmpops .ret0 ?+1
	0 ? test.cmp .exp0 .ret0 0


	# ----------------------- Minimum ------------------------
	# [exp0]=min([a],[b])
	.tmp0 .tmp0 ?+1
	.exp0 .z    ?+4
	.tmp0 .b    ?+4
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1

	0 ? test.measure .minops ?+7 0 ? uint.min .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 1

	# ----------------------- Maximum ------------------------
	# [exp1]=max([a],[b]). Use max=[a]+[b]-min.
	.exp0 .a    ?+1
	.exp0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .exp0 ?+1

	0 ? test.measure .maxops ?+7 0 ? uint.max .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 2

	# ------------------------- Set --------------------------
	0 ? test.measure .setops ?+6 0 ? uint.set .ret0 .a
	0 ? test.cmp .a .ret0 3

	# ----------------------- Negation -----------------------
	# Calculate -A manually.
	.exp0 .exp0 ?+1
	.exp0 .a    ?+1

	0 ? test.measure .negops ?+6 0 ? uint.neg .ret0 .a
	0 ? test.cmp .exp0 .ret0 4

	# ----------------------- Addition -----------------------
	# Calculate A+B manually.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp0 .b    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1

	0 ? test.measure .addops ?+7 0 ? uint.add .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 5

	# --------------------- Subtraction ----------------------
	# Calculate A-B manually.
	.exp0 .b    ?+1
	.exp0 .b    ?+1

	0 ? test.measure .subops ?+7 0 ? uint.sub .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 6

	# -------------------- Multiplication --------------------
	# Calculate A*B manually.
	.exp0 .exp0 ?+1
	# [tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	# [tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.mulloop:
	.tmp2 .z+1  .muldone
	# exp&lt;&lt;=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp1 ?+1
	.exp1 .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	# If [exp0] carries.
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	# [tmp1]&lt;&lt;=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .mulloop
	# [exp0]+=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	.tmp0 .tmp0 .mulloop
	.muldone:

	0 ? test.measure .mulops ?+8 0 ? uint.mul .ret1 .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 7
	0 ? test.cmp .exp1 .ret1 8

	# ----------------------- Division -----------------------
	# For B!=0, q=A/B, and r=A%B, we have A=q*B+r and r&lt;B.
	.b .z .div0
	.divden .z-1 ?+1
	0 ? test.measure .divops ?+8 0 ? uint.div .ret0 .ret1 .a .b
	0 ? uint.cmp .ret1 .b .remlt ?+2 ?+1
	0 ? test.cmp .z .b 9
	.remlt:
	0 ? uint.mul .tmp0 .tmp1 .ret0 .b
	0 ? test.cmp .z .tmp0 10
	0 ? uint.add .tmp1 .ret1 .tmp1
	0 ? test.cmp .a .tmp1 11
	.div0:

	# ---------------------- Shift Left ----------------------
	# Calculate A&lt;&lt;C manually.
	# [exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	# [tmp2]=-[c]
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.shlloop:
	.exp0 .z    .shldone
	.tmp2 .z    .shldone
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	.tmp2 .z-1  .shlloop
	.shldone:

	0 ? test.measure .shlops ?+7 0 ? uint.shl .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 12

	# --------------------- Shift Right ----------------------
	# Calculate A&gt;&gt;C manually.
	.exp0 .exp0 ?+1
	# [tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	# [tmp2]=-[c]-1
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.tmp2 .z+1  ?+1
	.shrloop:
	.tmp2 .nbits-1 .shrdone
	.tmp2 .bits+2 ?+1
	# [exp0]&lt;&lt;=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	# [tmp1]&lt;&lt;=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .shrloop
	.exp0 .z-1  .shrloop
	.shrdone:

	0 ? test.measure .shrops ?+7 0 ? uint.shr .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 13

	# ------------------------- Not --------------------------
	# ~A=-1-A
	.exp0 .exp0 ?+1
	.exp0 .z+1  ?+1
	.exp0 .a    ?+1

	0 ? test.measure .notops ?+6 0 ? uint.not .ret0 .a
	0 ? test.cmp .exp0 .ret0 14

	# ------------------------- And --------------------------
	# Calculate A&amp;B manually.
	# [exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	# [exp1]=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .tmp0 ?+1
	# [tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.andloop:
	.tmp2 .z+1  .anddone
	# [exp0]&lt;&lt;=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	# [exp1]&lt;&lt;=1
	.tmp1 .tmp1 ?+1
	.tmp1 .exp1 ?+1
	.tmp1 .z+1  ?+1
	# Set [exp0] if both carry.
	.exp1 .tmp1 .andloop
	.tmp0 .z    .andloop
	.tmp0 .hbit ?+4
	.tmp0 .tmp0 .andloop
	.exp0 .z-1  .andloop
	.anddone:

	0 ? test.measure .andops ?+7 0 ? uint.and .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 15

	# -------------------------- Or --------------------------
	# A|B=A+B-(A&amp;B)
	.ret0 .a    ?+1
	.ret0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .ret0 ?+1

	0 ? test.measure .orops ?+7 0 ? uint.or .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 16

	# ------------------------- Xor --------------------------
	# A^B=(A|B)-(A&amp;B)
	.exp1 .exp0 ?+1

	0 ? test.measure .xorops ?+7 0 ? uint.xor .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 17

	# Make sure parameters haven't been modified.
	0 ? test.cmp .a0 .a 18
	0 ? test.cmp .b0 .b 19
	0 ? test.cmp .c0 .c 20

	.trial .z-1 .loop

.done:
	# Print instruction counts.
	0 ? uint.div .cmpops 0 .cmpops .trial
	0 ? uint.div .minops 0 .minops .trial
	0 ? uint.div .maxops 0 .maxops .trial
	0 ? uint.div .setops 0 .setops .trial
	0 ? uint.div .negops 0 .negops .trial
	0 ? uint.div .addops 0 .addops .trial
	0 ? uint.div .subops 0 .subops .trial
	0 ? uint.div .mulops 0 .mulops .trial
	0 ? uint.div .divops 0 .divops .divden
	0 ? uint.div .shlops 0 .shlops .trial
	0 ? uint.div .shrops 0 .shrops .trial
	0 ? uint.div .notops 0 .notops .trial
	0 ? uint.div .andops 0 .andops .trial
	0 ? uint.div  .orops 0  .orops .trial
	0 ? uint.div .xorops 0 .xorops .trial
	0 ? string.print 'a 'v 'e 'r 'a 'g 'e '  'i 'n 's 't 'r 'u 'c 't 'i 'o
	                 'n 's '  'p 'e 'r '  'f 'u 'n 'c 't 'i 'o 'n 10 0
	0 ? string.print 'c 'm 'p ': '  string.uint .cmpops 10 0
	0 ? string.print 'm 'i 'n ': '  string.uint .minops 10 0
	0 ? string.print 'm 'a 'x ': '  string.uint .maxops 10 0
	0 ? string.print 's 'e 't ': '  string.uint .setops 10 0
	0 ? string.print 'n 'e 'g ': '  string.uint .negops 10 0
	0 ? string.print 'a 'd 'd ': '  string.uint .addops 10 0
	0 ? string.print 's 'u 'b ': '  string.uint .subops 10 0
	0 ? string.print 'm 'u 'l ': '  string.uint .mulops 10 0
	0 ? string.print 'd 'i 'v ': '  string.uint .divops 10 0
	0 ? string.print 's 'h 'l ': '  string.uint .shlops 10 0
	0 ? string.print 's 'h 'r ': '  string.uint .shrops 10 0
	0 ? string.print 'n 'o 't ': '  string.uint .notops 10 0
	0 ? string.print 'a 'n 'd ': '  string.uint .andops 10 0
	0 ? string.print '  'o 'r ': '  string.uint  .orops 10 0
	0 ? string.print 'x 'o 'r ': '  string.uint .xorops 10 0
	0 ? string.print 'p 'a 's 's 'e 'd 10 0


	# ------------------------ Timing ------------------------
	.tmp0 .tmp0 ?+1
	.tmp0 0-5   ?+1
	.time .tmp0 ?+1
	0 ? uint.div .time .tmp0 .time 0-4
	0 ? uint.mul 0 .tmp0 .tmp0 .timedec
	0 ? uint.div .tmp0 0 .tmp0 0-4
	0 ? string.print 't 'i 'm 'e ': '  string.uint .time '. string.uintinl .tmp0 10 6 '0 10 0

	0 ? mem.alloc.verifyfree

	# Exit
	0-1 0 ?-2


	# Variables
	0-2 0-1 .z:0 1
	.a:0
	.b:0
	.c:0
	.eqprob:64
	.hbit:0
	0-1 .nbits:0
	.bits:0 1 2
	.shiftmax:0
	.shiftsub:0
	.time:0
	.timedec:1000000
	.cmpops:0
	.minops:0
	.maxops:0
	.setops:0
	.negops:0
	.addops:0
	.subops:0
	.mulops:0
	.divops:0
	.divden:0
	.shlops:0
	.shrops:0
	.notops:0
	.andops:0
	.orops:0
	.xorops:0
	.trial:0
	.trials:25000
	.exp0:0
	.exp1:0
	.ret0:0
	.ret1:0
	.tmp0:0
	.tmp1:0
	.tmp2:0
	# Place these far away from .a, .b, and .c in order to minimize accidental use
	# by functions.
	.a0:0
	.b0:0
	.c0:0


test.rand.uint:
	# Call  : 0 ? test.rand ret
	# Effect: [ret]=(rand)
	# Generate a random integer such that the probability of any bitcount is uniform.
	# Setup new stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .p0     ?+1
	0       .z+2    ?+1
	0       .tmp0   ?+1
	.p0     0       ?+1
	.addr   0       ?+1
	0       0       ?+1
	# Get [ret]
	.tmp0   .tmp0   ?+1
	.tmp0   .p0:0   ?+1
	.p5     .p5     ?+1
	.p5     .tmp0   ?+1
	.p6     .p6     ?+1
	.p6     .tmp0   ?+1
	# Shuffle arr.
	0 ? random.shuffle .arr0 test.main.bits
	# Calculate how many bits we want to set.
	0 ? random.mod .i test.main.bits
	.tmp0   .tmp0   ?+1
	.b0     .b0     ?+1
	.b0     .narr   ?+1
	.i      .z-1    ?+1
.setbits:
	.i      .z+1    .setdone
	.tmp0   .b0:0   ?+1
	.b0     .z-1    .setbits
.setdone:
	# Return
	.tmp1   .tmp1   ?+1
	.tmp1   .p5:0   ?+1
	.tmp0   .tmp1   ?+1
	.p6:0   .tmp0   ?+1  # [ret]=[rand]
	0       0       .addr:1
	# Variables
	0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.i:0
	.arr:
		0x1 0x2 0x4 0x8 0x10 0x20 0x40 0x80 0x100 0x200 0x400 0x800 0x1000 0x2000 0x4000
		0x8000 0x10000 0x20000 0x40000 0x80000 0x100000 0x200000 0x400000 0x800000
		0x1000000 0x2000000 0x4000000 0x8000000 0x10000000 0x20000000 0x40000000
		0x80000000 0x100000000 0x200000000 0x400000000 0x800000000 0x1000000000
		0x2000000000 0x4000000000 0x8000000000 0x10000000000 0x20000000000 0x40000000000
		0x80000000000 0x100000000000 0x200000000000 0x400000000000 0x800000000000
		0x1000000000000 0x2000000000000 0x4000000000000 0x8000000000000 0x10000000000000
		0x20000000000000 0x40000000000000 0x80000000000000 0x100000000000000
		0x200000000000000 0x400000000000000 0x800000000000000 0x1000000000000000
		0x2000000000000000 0x4000000000000000 0x8000000000000000
	.arr0:.arr
	.narr:0-.arr


test.cmp:
	# Call  : 0 ? test.cmp exp val id
	# Setup stack.
	.tmp    .tmp    ?+1
	.tmp    .p0     ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.p0     0       ?+1
	.p2     0       ?+1
	.id     0       ?+1
	.ret    0       ?+1
	0       0       ?+1
	# Get [exp]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.exp    .tmp    ?+1
	# Get [val]
	.tmp    .tmp    ?+1
	.tmp    .p2:1   ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	# Compare [exp] and [val].
	.exp    .val    ?+1
	.exp    .z      .ret:3
	.exp    .tmp    ?+1
	# ERROR
	0 ? string.print 'E 'R 'R 'O 'R 10 0
	# line
	0 ? string.print 't 'r 'i 'a 'l '  ': '  string.uint test.main.trial 10 0
	# test
	0 ? string.print 't 'e 's 't '  '  ': '  string.uint .id:2 10 0
	# expect
	0 ? string.print 'e 'x 'p 'e 'c 't ': '  string.uint .exp 10 0
	# return
	0 ? string.print 'r 'e 't 'u 'r 'n ': '  string.uint .val 10 0
	0-1 0 ?-2
	# Variables
	.exp:0
	.val:0
	.z:0 1 2
	.tmp:0


test.measure:
	# 0 ? test.measure counter return 0 ? func arg0 arg1 ...
	# counter = the address for counting instructions.
	# return  = address the function will return to when finished.
	# Emulates the execution of a function and measures how many instructions it uses.
	# Uses 24+20*n instructions for n emulated instructions.
	.tmp    .a0     ?+1
	.nret   .tmp    ?+1
	.tmp    0       ?+1
	.dif    .tmp    ?+1
	.dif    .z+4    ?+1
	# Setup counter.
	0       .z+2    ?+1
	.p0     .p0     ?+1
	.p0     0       ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.cnt    .cnt    ?+1
	.cnt    .tmp    ?+1
	# Get the negative return address. If [nret]+[dif0]+[dif1]+...=0, then return.
	0       .z+1    ?+1
	.p1     .p1     ?+1
	.p1     0       ?+1
	.nret   .p1:0   ?+1
	# Reset stack address.
	0       0       .loop
.jmp:
	# We jumped, set [dif]=[a0]-[c].
	.tmp    .tmp    ?+1
	.tmp    .a0     ?+1
	.dif    .tmp    ?+1
.loop:
	# Update a, b, and c addresses.
	.a0     .dif    ?+1
	.b0     .dif    ?+1
	.c0     .dif    ?+1
	.nret   .dif    ?+1
	.dif    .dif    ?+1
	# Return if ip=[ret].
	.nret   .z      .ret
	# Increment the instruction counter.
	.cnt:0  .z-1    ?+1
	# Load [a]. a0 will hold the return address when we're done.
	.tmp    .tmp    ?+2
	.ret:   .tmp
	.tmp    .a0:0   ?+1
	.a      .a      ?+1
	.a      .tmp    ?+1
	# Load [b].
	.tmp    .tmp    ?+1
	.tmp    .b0:1   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	# Set [dif]=-[c].
	.dif    .c0:2   ?+1
	# Execute instruction.
	.a:0    .b:0    .jmp
	# We failed to jump, set [dif]=-3.
	.dif    .dif    ?+1
	.dif    .z+3    .loop
	# Variables
	.tmp:0
	.nret:0
	.dif:0
	0-2 0-1 .z:0 1 2 3 4


#|==============================================================================


SICO Master Library

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


master.sico contains all basic libraries for ease of use in other projects.

This library should be included after any other sico files. Display an error
message and exit if it's not.


          File      |  Line
     ---------------+--------
         uint.sico  |    43
          int.sico  |  1966
       random.sico  |  3334
       string.sico  |  3941
       memory.sico  |  4493


|#


master:
	.len    .z+1    .z-1
	0-2     .ptr    ?+1
	?-2     .z-1    master
	0-1 .z:0 1
	.ptr: 'E 'R 'R 'O 'R ': '  'm 'a 's 't 'e 'r '. 's 'i 'c
	      'o '  'm 'u 's 't '  'b 'e '  'i 'n 'c 'l 'u 'd 'e
	      'd '  'l 'a 's 't 10
	.len: .len-.ptr+1


#|==============================================================================


Unsigned Integer Library - v5.06

Copyright 2020 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


uint.sico provides functions for performing most of the common unsigned integer
operations. In particular, it handles: comparisons, arithmetic, and bitwise
operations.

SICO typically uses integers modulo 2^64. However: string, integer arithmetic,
and comparison functions will work with any modulo. Bitwise functions, on the
other hand, require integers modulo 2^n.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |    Complexity     |  Instructions
                 |                   |   (64 bits)
     ------------+-------------------+----------------
         write   |  --               |     2303
          read   |  --               |     1456
           cmp   |  29               |       29
           min   |  34               |       34
           max   |  34               |       34
           set   |  24               |       24
           neg   |  25               |       25
           add   |  30               |       30
           sub   |  31               |       31
           mul   |  55 + 12.97*bits  |      885
           div   |  60 +  8.65*bits  |      613
           gcd   |  40 + 20.17*bits  |     1330
           shl   |  40 +  2.00*bits  |      168
           shr   |  31 +  8.00*bits  |      543
           not   |  26               |       26
           and   |  37 +  7.00*bits  |      485
            or   |  38 +  7.00*bits  |      486
           xor   |  39 +  7.00*bits  |      487


--------------------------------------------------------------------------------
Index


Strings
uint.write [mem] [memlen] [memidx] retidx [num] [base]
uint.read  [mem] [memlen] [memidx] retidx retnum [base]

Comparisons
uint.cmp [a] [b] lt eq gt
uint.min [ret] [a] [b]
uint.max [ret] [a] [b]

Integer Arithmetic
uint.set [ret]  [a]
uint.neg [ret]  [a]
uint.add [ret]  [a] [b]
uint.sub [ret]  [a] [b]
uint.mul [high] [low] [a] [b]
uint.div [quot] [rem] [num] [den]

Number Theory
uint.gcd [ret] [a] [b]

Bitwise Arithmetic
uint.shl [ret] [num] [shift]
uint.shr [ret] [num] [shift]
uint.not [ret] [a]
uint.and [ret] [a] [b]
uint.or  [ret] [a] [b]
uint.xor [ret] [a] [b]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version. Used uint.cmp, mem.get, and mem.set for proof of concept.
     Functions take tens of thousands of instructions.
2.00
     Inlined functions so they don't use mem.get and mem.set.
     Functions take thousands of instructions.
3.00
     Optimized functions so they are all under or around 1K instructions.
3.01
     Optimized uint.and, uint.or, and uint.xor so the final value is stored in
     [a]. This removes the need for a temporary storage variable.
     Cleaned up uint.cmp so its branching is more straight forward.
3.02
     Optimized uint.set and uint.add to remove 1 instruction.
3.03
     Fixed an error in uint.mul when carrying from low to high. Removed need to
     offset [b] by 1 to check for carrying.
     Updated formatting for uint.cmp.
     Changed uint.div to abort with 0xd0 when dividing by 0.
     Optimized uint.and, uint.or, and uint.xor by skipping first loop check.
3.04
     Optimized uint.and, uint.or, and uint.xor by 18%. [a] and [b] only need to
     be offset by 1 on the first loop. This removes 2 decrement instructions per
     loop.
3.05
     Optimized uint.and, uint.or, and uint.xor by 11%. Removed the iteration
     counter and instead check if [b]=0. We only set the bottom bit of [a] in
     1/4 of cases, and only check if [b]=0 in 1/2 of cases. uint.or and uint.xor
     are based off of uint.and for their loop.
3.06
     Updated comments.
3.07
     Replaced average case time complexity with worst case time complexity.
     Standardized formatting to 8 spaces per column.
3.08
     Updated comments.
3.09
     Changed division-by-0 abort instruction.
     Made uint.shl bit length agnostic and lowered run time by 36%.
     Made uint.shr bit length agnostic and lowered run time by 11%.
3.10
     Added uint.min and uint.max.
     Updated timing measurements to not count calling instruction.
4.00
     Re-added calling instruction to timing measurements.
     Modified uint.shl to calculate bit length on first run.
     Updated descriptions for uint.mul, uint.div, and uint.and.
     Made uint.mul bit length agnostic and lowered run time by 5%.
     Made uint.div bit length agnostic and lowered run time by 6%.
     All functions are now bit length agnostic.
4.01
     Simplified loop termination in uint.mul and uint.div. This is 5% faster.
     uint.mul will skip calculating [high] if high=0. This is 44% faster.
     uint.div will skip calculating [quot] if quot=0. This is 29% faster.
4.02
     Removed bit counting in uint.shl and lowered run time by 6%.
     Simplified uint.shr initialization.
4.03
     Removed a testing function for uint.shl that was included by accident.
     Cleaned up function descriptions.
4.04
     Added uint.print for string printing.
4.05
     Corrected timing for uint.cmp.
4.06
     Lowered run time of uint.min and uint.max from 38 to 34 instructions.
     Cleaned up variable names in uint.set, uint.neg, uint.add, and uint.sub.
     Removed unnecessary instructions from uint.mul when high=0.
5.00
     All integer arithmetic functions work with any modulo on the underlying
     integers.
     Remade uint.div and uint.mul to work with any modulo, even non
     power-of-two, by using the fibonacci sequence.
     uint.div is 30% faster and uint.mul is 1% faster.
     Cleaned up version history comments.
5.01
     Added uint.gcd.
5.02
     Improved the time complexity of uint.gcd from log^2(n) to log(n).
5.03
     Updated comments.
     Removed a few instructions from uint.div and uint.gcd.
5.04
     Replaced uint.print with uint.writestring. This will allow the integer and
     string libraries to interact more naturally.
     Added uint.readstring.
5.05
     Replaced ASCII codes with ASCII literals.
5.06
     Renamed readstring/writestring to read/write so that the functions no
     longer imply that they work with string objects.


--------------------------------------------------------------------------------
TODO


Optimize uint.mul to have same time complexity as uint.div
	We don't need to shift hval0 or hval1 in loop. We know that if 1 is added
	to hval0, it will end up as hval0+fib0 at the end of the loop. Just add/sub
	fib0 or fib1 to hval0 and hval1 when a carry occurs.
	Unroll first loop iteration and simplify loop?
	See if 2*fib0+fib1&lt;MOD limit works better than fib0+fib1&lt;MOD.
	mul_opt.cpp, map lval0/lval1 carries to integers. See if unique.

Optimize or/and/xor. Simplify top bit setting by changing .done jump destination
when terminating loop.

Expand uint.write to allow base 36. Get rid of translation table. Simplify
[char] to value translation in uint.readstring.

Get rid of mod testing with uint_test.cpp and replace with uint_test.sico.


|#


#---------------------------------------------------------------------------------
# Strings


uint.write:
	# Call  : 0 ? uint.write mem memlen memidx retidx num base
	#
	# Effect: Converts an unsigned integer to ASCII and writes it to memory.
	#       : [base] &lt;= 16
	#       : The first character is written to [mem]+[memidx].
	#       : The function does not write after [mem]+[memlen]-1 or if [mem]=0,
	#       : but [retidx] will still be updated.
	#       : [retidx] = [memidx] + (length of the ASCII string)
	#       : If [retidx]&gt;[memlen], then the string needs to be resized.
	#       : If retidx=0, then [retidx] is not written to.
	#       : Base = 0: c0*0^0 + c1*0^1 + c2*0^2 + ... = c0
	#       : Base = 1: c0*1^0 + c1*1^1 + c2*1^2 + ... = hash marks
	#       : Base &gt; 1: regular number
	#
	# Time  : Base = 0: 82
	#       : Base = 1: 80 + 9*MOD
	#       : Base &gt; 1: 63 + (23 + 6*base)*digits = 2303
	#       : digits = ceil(ln(MOD)/ln(base))
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	.arg8   0       ?+1
	0       0       ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.mem    .mem    ?+1
	.mem    .tmp    ?+1
	# Get [memidx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nidx   .nidx   ?+1
	.nidx   .p4:0   ?+1
	# Get [memlen]. If [mem]=0 or [memlen]&lt;=[memidx], set [memlen]=0.
	.mem    .z      .len0
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.memlen .memlen ?+1
	.memlen .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .nidx   ?+1
	.memlen .tmp    .len0
	.memlen .z-1    ?+4
.len0:
	.memlen .memlen ?+1
	# Get retidx.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.p6     .p6     ?+1
	.p6     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p6:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	# Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg7:7 ?+1
	.p7     .p7     ?+1
	.p7     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p7:0   ?+1
	# Set string pointers.
	.nidx   .mem    ?+1
	.mem0   .mem0   ?+1
	.mem0   .nidx   ?+1
	.mem1   .mem1   ?+1
	.mem1   .nidx   ?+1
	.mem2   .mem2   ?+1
	.mem2   .nidx   ?+1
	.wret   .wret   ?+1
	# Make sure [base] &lt;= 16.
	.nbase  .z      .base0loop
	.base   .base   ?+1
	.base   .nbase  ?+1
	.base   .nbase  ?+1
	.nbase  .n17    .ret
	.nbase  .z15    .base1skip
.base1loop:
	# [base] = 1. Print hash marks.
	.num    .z      .ret
	.wret   .wretb1 ?+4
	.num    .z+1    .ret
	.nchar  .hex+2  .write
.base0loop:
	# [base] = 0. [char]=[num].
	.wret   .wretb0 ?+1
	.nchar  .num    .write
.base1skip:
	# Calculate the most significant digit and how many digits are in [num].
	.nbase  .nbase  ?+1
	.nbase  .base   ?+1
	.den    .den    ?+1
	.den    .z-1    ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.msdloop:
	.digits .z-1    ?+1
	.chr    .base   ?+1
	# Loop: num -= den
	.num    .den    .msddone
	.chr    .z-2    ?-5
	# den = den*base
	.nden   .nden   ?+1
	.nden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.num    .num    ?+1
	.num    .nnum   .msdloop
.msddone:
	# num += den if num&gt;0. If the original [num]=0, skip any correction.
	.nnum   .z      .nextloop-6
	.tmp    .tmp    ?+1
	.num    .z      ?+4
	.tmp    .den    ?+4
	.chr    .z-2    ?+4
	.num    .tmp    .msdloop+12
	.den    .den    ?+1
	.den    .nden   ?+1
	.base   .z+2    ?+1
	.chr    .nbase  ?+1
	.wret   .wret0  .nextwrite
.nextloop:
	.digits .z+1    .ret
	# digit = num/den
	.chr    .chr    ?+1
	.num    .den    ?+4
	.chr    .z-2    ?-5
	# num = num*base
	.num    .z      ?+7
	.num    .nden   ?+1
	.nnum   .nnum   ?+4
	.chr    .z-2    ?-5
	.z+1    .base   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.nextwrite:
	# Write a digit.
	.chr    .nhex   ?+1
	.nchar  .chr:0  .write
.write:
	# Mini function to write a character to the string.
	.memlen .z+1    .writeskip
	.mem0:0 .mem1:0 ?+1
	.mem2:0 .nchar  ?+1
	.mem2   .z-1    ?+1
	.mem1   .z-1    ?+4
.writeskip:
	.memlen .memlen ?+1
	.mem0   .z-1    ?+1
	.nchar  .nchar  .wret:0
.ret:
	# return [retidx] = [mem0] - [mem]
	.mem0   .ret0:0 ?+1
	.mem    .mem0   ?+1
	.ret1:0 .mem    ?+1
	0       0       .arg8:8
	# Variables
	0-2 0-1 .z:0 1 2
	.n17:0-17
	.z15:15
	.tmp:0
	.nnum:0
	.num:0
	.nbase:0
	.base:0
	.digits:0
	.den:0
	.nden:0
	.nchar:0
	.nidx:0
	.memlen:0
	.mem:0
	.hex:
		'0 '0 '1 '1 '2 '2 '3 '3 '4 '4 '5 '5 '6 '6 '7 '7
	     '8 '8 '9 '9 'a 'a 'b 'b 'c 'c 'd 'd 'e 'e 'f 'f
	.nhex:0-.hex
	.wretb0:0-.ret
	.wretb1:0-.base1loop-6
	.wret0:0-.nextloop


uint.read:
	# Call  : 0 ? uint.read mem memlen memidx retidx retnum base
	#
	# Effect: Converts ASCII characters into an unsigned integer.
	#       : [base] &lt;= 36
	#       : [retnum] = return value.
	#       : The first character is read from [mem]+[memidx].
	#       : The function does not read after [mem]+[memlen]-1 or if [mem]=0,
	#       : but [retidx] will still be updated.
	#       : [retidx] = [memidx] + (number of read characters)
	#       : If retidx=0, then [retidx] is not written to.
	#
	# Time  : Base = 1: 94 + 19*MOD
	#       : Base &gt; 1: 112 + (17 + 2*base)*digits = 1456
	#       : digits = ceil(ln(MOD)/ln(base))
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	.arg8   0       ?+1
	0       0       ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.mem    .mem    ?+1
	.mem    .tmp    ?+1
	# Get [memidx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p4:0   ?+1
	.memidx .memidx ?+1
	.memidx .tmp    ?+1
	# Set string pointers.
	.tmp    .mem    ?+1
	.mem0   .mem0   ?+1
	.mem0   .tmp    ?+1
	# Get retidx.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get retnum.
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.ret2   .ret2   ?+1
	.ret2   .tmp    ?+1
	.ret3   .ret3   ?+1
	.ret3   .tmp    ?+1
	.num    .num    ?+1
	# Get [memlen]. If [mem]=0 or [memlen]&lt;=[memidx], return.
	.mem    .z      .ret+3
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.memlen .memlen ?+1
	.memlen .tmp    ?+1
	.memlen .memidx .ret+3
	.memlen .z-1    ?+1
	# Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg7:7 ?+1
	.p7     .p7     ?+1
	.p7     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p7:0   ?+1
	# Make sure [base] &lt;= 36.
	.rret   .rret   ?+1
	.nbase  .z      .base0loop
	.base   .base   .base0skip
.base0loop:
	.rret   .rret0  ?+1
	.char   .char   .read
	.num    .nchar  .ret+3
.base0skip:
	# [max]=[base]-1. If [base]=1, we allow [char] to be 0 or 1.
	.max    .max    ?+1
	.nbase  .z-2    ?+4
	.max    .z-1    .whiteloop
	.nbase  .z+1    ?+1
	.base   .nbase  ?+1
	.base   .nbase  ?+1
	.max    .nbase  ?+1
	.nbase  .n36    .ret+3
	# Read whitespace
.whiteloop:
	.rret   .rret1  ?+1
	.char   .char   .read
	.char   .z32    ?-5
	.char   .n32    ?+1
	.rret   .rret2  ?+1
.parseloop:
	# [char] &gt;= 'a'
	.char   .ca1    ?+4
	.char   .n9     .parsedone
	.char   .nca1   ?+1
	# [char] &gt;= 'A'
	.char   .cA1    ?+4
	.char   .n9     .parsedone
	.char   .ncA1   ?+1
	# [char] &gt;= '0'
	.nchar  .nc91   .ret
	.char   .c01    .ret
	.char   .z+1    ?+1
.parsedone:
	# If [char] &gt;= [max], abort.
	.nchar  .nchar  ?+1
	.nchar  .char   ?+1
	.char   .max    ?+4
	.mem    .z-1    .ret+3
	# num += num*(base-1)
	.z+1    .base   ?+4
	.tmp    .tmp    ?+13
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.z+1    .z-2    ?-5
	# num += char
	.num    .nchar  ?+1
	.char   .char   .read
.read:
	# Mini function to read a character from the string.
	.memlen .z+1    .ret+3
	.nchar  .nchar  ?+1
	.nchar  .mem0:0 ?+1
	.char   .nchar  ?+1
	.mem0   .z-1    .rret:0
.ret:
	# return [retidx] = [mem0] - [mem]
	.mem0   .z+1    ?+1
	.mem0   .ret0:0 ?+1
	.mem    .mem0   ?+1
	.ret1:0 .mem    ?+1
	# return [retnum]
	.tmp    .tmp    ?+1
	.num    .ret2:0 ?+1
	.tmp    .num    ?+1
	.ret3:0 .tmp    ?+1
	0       0       .arg8:8
	# Variables
	0-2 0-1 .z:0 1 2
	.n36:0-36
	.n32:0-32
	.n9:0-9
	.z32:32
	.tmp:0
	.num:0
	.nbase:0
	.base:0
	.nchar:0
	.char:0
	.max:0
	.mem:0
	.memlen:0
	.memidx:0
	.rret0:0-.base0loop-6
	.rret1:0-.whiteloop-6
	.rret2:.whiteloop+6-.parseloop
	.ca1: 'a-1
	.nca1:1-'a
	.cA1: 'A-1
	.ncA1:1-'A
	.c01: '0-1
	.nc91:0-'9-1



#---------------------------------------------------------------------------------
# Comparisons


uint.cmp:
	# Call  : 0 ? uint.cmp a b lt eq gt
	#
	# Effect: if [a]&lt;[b]: goto lt
	#       : if [a]=[b]: goto eq
	#       : if [a]&gt;[b]: goto gt
	#
	# Time  : 29
	#
	# Use [0] to get the calling address.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	# Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	.z      .p0:0   ?+1
	.a      .a      ?+1
	.a      .z      ?+1
	# Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.b      .b      ?+1
	.b      .z      ?+1
	# Compute [a]-[b]
	.z      .z      ?+1
	.a      .b:0    .le
	# If [a]&gt;[b]
	.z      .arg6:6 .ret
.le:
	.a      .z      .eq
	# If [a]&lt;[b]
	.z      .arg4:4 .ret
.eq:
	# If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	# Variables
	.z:0 1 2
	.a:0


uint.min:
	# Call  : 0 ? uint.min ret a b
	#
	# Effect: [ret] = min([a],[b])
	#
	# Time  : 34
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.a      .p4:0   ?+4
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


uint.max:
	# Call  : 0 ? uint.max ret a b
	#
	# Effect: [ret] = max([a],[b])
	#
	# Time  : 34
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	# Set [ret]
	.a      .p4:0   ?+4
	.tmp    .tmp    ?+7
	.tmp    .tmp    ?+1
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


#---------------------------------------------------------------------------------
# Integer Arithmetic


uint.set:
	# Call  : 0 ? uint.set ret a
	#
	# Effect: [ret] = [a]
	#
	# Time  : 24
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	# Return
	0       0       .arg4:4
	# Variables
	.off:2
	.tmp:0


uint.neg:
	# Call  : 0 ? uint.neg ret a
	#
	# Effect: [ret] = -[a]
	#
	# Time  : 25
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .ret0:0 ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ret1:0 .val    ?+1
	# Return
	0       0       .arg4:4
	# Variables
	.off:2
	.tmp:0
	.val:0


uint.add:
	# Call  : 0 ? uint.add ret a b
	#
	# Effect: [ret] = [a] + [b]
	#
	# Time  : 30
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .b0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0


uint.sub:
	# Call  : 0 ? uint.sub ret a b
	#
	# Effect: [ret] = [a] - [b]
	#
	# Time  : 31
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	# Set [ret]
	.val    .val    ?+1
	.val    .ret1:0 ?+1
	.val    .b0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .val    ?+1
	.ret0:0 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0
	.val:0


uint.mul:
	# Call  : 0 ? uint.mul high low a b
	#
	# Effect: [high] = [a]*[b] / MOD
	#       : [low]  = [a]*[b] % MOD
	#
	# Time  : 55 + 12.97*bits = 885
	#       : 47 +  7.21*bits = 508 if high=0
	#
	# Deconstruct [b] into a sum of fibonacci numbers (ex: 15=11+3+1). At the same
	# time, calculate [a]*[b] by building up a separate fibonacci sequence and adding
	# [a] to it every time a fibonacci number is a part of [b]'s sum.
	#
	# The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 32 + 9*n(F)
	#     time = 34 + 5*n(F) if high=0
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    .firstrun
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	# Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get -[b]. We will flip the sign of the result later.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .b0:0   ?+1
	.lval0  .lval0  ?+1
	.lval1  .lval1  ?+1
	# Get high. If [hret]=0, skip calculating the high value.
	.hret   .arg2:2 ?+1
	.hret   .z      .lowonly
	# ------- Calculate [lval] and [hval] --------
	.hval0  .hval0  ?+1
	.hval1  .hval1  ?+1
	.nb     .z      .highzero
	.na     .z      .highzero
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .hstart:.highfib0+9
	# During each loop, fibonacci decrement the [nb]. If [nb]&gt;[fib], reduce [nb]
	# and add [a] to the return value. Then fibonacci increment the return value.
.highfib0:
	.fib1   .fib0   .highret
	.hval0  .hval1  ?+1
	# If [lval0]&lt;=[lval1], check for a carry into [hval0].
	.lval0  .lval1  .highfib1-6
	# If [nb]&gt;[fib0], add [a] to [lval0] and check for a carry into [hval0].
	.nb     .fib0   ?+16
	.lval0  .na     ?+7
	.hval0  .z+1    ?+1
	.nfib0  .nfib1  .highfib1
	.lval0  .z      ?-8
	.nfib0  .nfib1  .highfib1
	# [nb]&lt;=[fib0], so restore [nb].
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .highfib1
	# Checking for a carry from [lval0]-[lval1].
	.lval0  .z      .highfib0+9
	.hval0  .z-1    .highfib0+9
.highfib1:
	.fib0   .fib1   .highret
	.hval1  .hval0  ?+1
	# If [lval1]&lt;=[lval0], check for a carry into [hval1].
	.lval1  .lval0  .lowonly-6
	# If [nb]&gt;[fib1], subtract [a] from [lval1] and check for a carry into [hval1].
	.nb     .fib1   ?+13
	.lval1  .a      ?+4
	.nfib1  .nfib0  .highfib0
	.lval1  .z      ?-5
	.hval1  .z-1    ?-8
	# [nb]&lt;=[fib1], so restore [nb].
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .highfib0
	# Checking for a carry from [lval1]-[lval0].
	.lval1  .z      .highfib1+9
	.hval1  .z-1    .highfib1+9
	# ---------- Only calculate [lval] -----------
.lowonly:
	.nb     .z      .lowret+3
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .lstart:.lowfib0+6
	# During each loop, fibonacci decrement the [nb]. If [nb]&gt;[fib], reduce [nb]
	# and add [a] to the return value. Then fibonacci increment the return value.
.lowfib0:
	.fib1   .fib0   .lowret
	.lval0  .lval1  ?+1
	# If [nb]&gt;[fib0], add [a] to [lval0].
	.nb     .fib0   ?+7
	.lval0  .na     ?+1
	.nfib0  .nfib1  .lowfib1
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .lowfib1
.lowfib1:
	.fib0   .fib1   .lowret
	.lval1  .lval0  ?+1
	# If [nb]&gt;[fib1], subtract [a] from [lval1].
	.nb     .fib1   ?+7
	.lval1  .a      ?+1
	.nfib1  .nfib0  .lowfib0
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .lowfib0
	# -------------- Return values ---------------
.highret:
	# Calculate the low return value and subtract [a] from it.
	# Also check for final carries into the high value.
	.lval0  .lval1  ?+4
	.hval1  .z-1    ?+4
	.lval0  .z      ?-5
	.lval0  .na     ?+4
	.hval1  .z-1    ?+1
	.lval1  .lval1  ?+1
	.hval0  .na     ?+1
.highzero:
	# Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.hval0  .h0:0   ?+1
	.hval1  .hval0  ?+1
	.h1:0   .hval1  ?+1
	.hret   .hret   .lowret+3
.lowret:
	# Set [low]
	.lval0  .na     ?+1
	.lval1  .l0:0   ?+1
	.lval0  .lval1  ?+1
	.l1:0   .lval0  ?+1
	# Return
	0       0       .arg6:6
	# On the first run, calculate the largest fibonacci values that can fit in our
	# underlying integers.
	.fdif:.firstrun-uint.mul-3
	.hdif:.highfib0-.highfib1
	.ldif:.lowfib0-.lowfib1
.firstrun:
	uint.mul+2 .fdif ?+1
	.nfib1i .fib0i  .firstset1
	.fib0i  .nfib1i ?-5
.firstset0:
	# If [fib0]&lt;[fib1], start on [fib1] loop.
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+1
	.nfib0i .fib0i  ?+1
	.hstart .hdif   ?+1
	.lstart .ldif   ?+1
	.fib1i  .z+1    ?+1
	.nfib1i .z-1    uint.mul+3
.firstset1:
	.nfib0i .fib0i  ?+1
	.nfib1i .nfib0i ?+1
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+4
	.fib0i  .nfib1i .firstset1-6
	.nfib0i .nfib0i .firstset0+3
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.na:0
	.nb:0
	.hret:0
	.hval0:0
	.hval1:0
	.lval0:0
	.lval1:0
	.fib0i:1
	.nfib0i:0
	.fib1i:0
	.nfib1i:0-1
	.fib0:0
	.nfib0:0
	.fib1:1
	.nfib1:0-1


uint.div:
	# Call  : 0 ? uint.div quot rem num den
	#
	# Effect: [quot] = [num] / [den] rounded down
	#       : [rem]  = [num] % [den]
	#
	# Time  : 60 + 8.65*bits = 613
	#       : 50 + 7.21*bits = 511 if quot=0
	#
	# Use the fibonacci sequence to build up [den]. Then run the sequence in
	# reverse to calculate [num]%[den]. While calculating the remainder, calculate
	# the quotient [num]/[den] by using another, separate fibonacci sequence.
	#
	# The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 44 + 6*n(F)
	#     time = 36 + 5*n(F) if quot=0
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	# Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	# Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	# Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden1  .nden1  ?+1
	.nden1  .p1:0   ?+1
	# If [den]=0, abort.
	.nden1  .z      .divz
	# Get quot. If [qret]=0, skip calculating the quotient.
	.qret   .arg2:2 ?+1
	# If [den]*2&gt;=MOD, we need to skip calculating the largest multiple of [den].
	.den0   .nden1  ?+1
	.nden1  .den0   ?+4
	.den1   .den1   ?+7
	.den1   .den1   .denhalf
	# Calculate the largest fibonacci multiple of [den].
.denloop:
	.nden1  .den0   .denstart0
	.den0   .nden1  .denloop
.denstart1:
	# [den1]&gt;[den0]. Fill in the rest of the denominators.
	.den1   .nden1  ?+1
	.den0   .den1   ?+1
	.nden0  .den0   ?+1
	.qret   .z      .remden1+3
	.quot0  .quot0  .quotden1+6
.denstart0:
	# [den0]&gt;=[den1]. Fill in the rest of the denominators.
	# If [den0]=[den1], we need to swap values.
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.den0   .den1   ?+4
	.den0   .nden1  .denhalf+9
	.nden0  .nden0  .denstart1+3
.denhalf:
	# [den]*2&gt;=MOD. Manually set the denominators to +-[den].
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.qret   .z      .remden0+3
	.quot0  .quot0  .quotden0+6
	# -------- Calculate [rem] and [quot] --------
	# During each loop, fibonacci decrement the denominator and increment the
	# quotient. If [num]&gt;[den], reduce [num] and increment the quotient by 1.
.quotden0:
	.den1   .den0   .quotret
	.quot0  .quot1  ?+1
	# Test if [num]&gt;[den0].
	.num    .den0   ?+7
	.quot0  .z-1    ?+1
	.nden0  .nden1  .quotden1
	.num    .nden0  ?+1
	.nden0  .nden1  .quotden1
.quotden1:
	.den0   .den1   .quotret
	.quot1  .quot0  ?+1
	# Test if [num]&gt;[den1].
	.num    .den1   ?+7
	.quot1  .z+1    ?+1
	.nden1  .nden0  .quotden0
	.num    .nden1  ?+1
	.nden1  .nden0  .quotden0
	# ----------- Only calculate [rem] -----------
	# During each loop, fibonacci decrement the denominator. If [num]&gt;[den],
	# reduce [num].
.remden0:
	.den1   .den0   .remret
	# Test if [num]&gt;[den0].
	.num    .den0   ?+4
	.nden0  .nden1  .remden1
	.num    .nden0  ?+1
	.nden0  .nden1  .remden1
.remden1:
	.den0   .den1   .remret
	# Test if [num]&gt;[den1].
	.num    .den1   ?+4
	.nden1  .nden0  .remden0
	.num    .nden1  ?+1
	.nden1  .nden0  .remden0
	# -------------- Return values ---------------
.quotret:
	# Set [quot]. Because of how additions are split, return [quot0]-[quot1]+1.
	.den1   .num    ?+4
	.den1   .den1   ?+7
	.num    .num    ?+1
	.quot0  .z-1    ?+1
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.quot0  .r0:0   ?+1
	.quot1  .quot0  ?+1
	.r1:0   .quot1  ?+1
	.quot1  .quot1  ?+1
	.qret   .qret   .remret+9
.remret:
	# Set [rem]=[num]-[den1].
	.den1   .num    ?+4
	.den1   .den1   ?+4
	.num    .num    ?+1
	.num    .r2:0   ?+1
	.den1   .num    ?+1
	.r3:0   .den1   ?+1
	# Return
	0       0       .arg6:6
.divz:
	# Division by 0. Abort.
	0-1     0       ?-2
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den0:0
	.nden0:0
	.den1:0
	.nden1:0
	.qret:0
	.quot0:0
	.quot1:0


#---------------------------------------------------------------------------------
# Number Theory


uint.gcd:
	# Call  : 0 ? uint.gcd ret a b
	#
	# Effect: [ret] = gcd([a],[b])
	#
	# Time  : 40 + 20.17*bits = 1330
	#
	# Calculate the greatest common denominator using the Euclidean algorithm. By
	# dynamically calculating the modulus, this algorithm has log time complexity.
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.a      .a      ?+1
	.a      .tmp    ?+1
	# Get -[b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nmul0  .nmul0  ?+1
	.nmul0  .p4:0   ?+1
	# Make sure [a]!=0 and [b]!=0, or we'll loop forever.
	.nmul0  .z      .ret
	.a      .z      .ret
.loop:
	# [mul1]=[b].
	.mul1   .mul1   ?+1
	.mul1   .nmul0  ?+1
	.nmul0  .nmul0  ?+1
	# Find the largest multiple of [b]&lt;=[a], and reduce [a] as well.
	.a      .mul1   .muldone+3
.mulloop:
	.a      .mul1   .muldone
	.a      .mul1   .muldone
	.nmul0  .mul1   ?+1
	.mul1   .nmul0  .mulloop
.muldone:
	.mul0   .nmul0  ?+1
	.nmul1  .nmul1  ?+1
	.nmul1  .mul1   .mod1+9
	# Calculate [a]%[b].
.mod0:
	.mul1   .mul0   .moddone
	# Test if [a]&gt;[mul0].
	.a      .mul0   ?+4
	.nmul0  .nmul1  .mod1
	.a      .nmul0  ?+1
	.nmul0  .nmul1  .mod1
.mod1:
	.mul0   .mul1   .moddone
	# Test if [a]&gt;[mul1].
	.a      .mul1   ?+4
	.nmul1  .nmul0  .mod0
	.a      .nmul1  ?+1
	.nmul1  .nmul0  .mod0
.moddone:
	# If [mul1]=[b]&lt;=[a], then [a]%[b]=0, so return [b].
	.mul1   .a      .ret
	# Otherwise, swap [a] and [b], and continue the algorithm.
	.nmul0  .a      ?+1
	.a      .a      ?+1
	.a      .nmul1  .loop
.ret:
	# Return the gcd. Either [a]=0 or [nmul0]=-[b]=0, so [a]-(-[b])=gcd.
	.a      .ret0:0 ?+1
	.nmul0  .a      ?+1
	.ret1:0 .nmul0  ?+1
	0       0       .arg5:5
	# Variables
	.z:0 1 2
	.a:0
	.tmp:0
	.nmul0:0
	.nmul1:0
	.mul0:0
	.mul1:0


#---------------------------------------------------------------------------------
# Bitwise Arithmetic


uint.shl:
	# Call  : 0 ? uint.shl ret num shift
	#
	# Effect: [ret] = [num] &lt;&lt; [shift]
	#
	# Time  : 56 + 16*floor((bits-1)/8) = 168
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.shift  .tmp    ?+1
	# Get -[num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   .done8-3
	# [num]=[num]&lt;&lt;8. Abort if [num]=0.
.loop8:
	.num    .z      .ret
	.shift  .p8     .done8
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop8
.done8:
	.shift  .z      .loop8+6
	.shift  .n8     .done1
	# [num]=[num]&lt;&lt;3
	.shift  .z+2    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	# [num]=[num]&lt;&lt;3
	.shift  .z+3    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+4
.done3:
	.shift  .z-3    ?+1
	# [num]=[num]&lt;&lt;1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	# [num]=[num]&lt;&lt;1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
.ret:
	.shift  .shift  ?+1
.done1:
	# Set [ret].
	.tmp    .ret0:0 ?+1
	.num    .tmp    ?+1
	.ret1:0 .num    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-3 0-2 0-1 .z:0 1 2 3
	.p8:8
	.n8:0-8
	.num:0
	.shift:0
	.tmp:0


uint.shr:
	# Call  : 0 ? uint.shr ret num shift
	#
	# Effect: [ret] = [num] &gt;&gt; [shift]
	#
	# Time  : 31 + 8*bits = 543
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	# Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	# Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	# If [shift]&gt;=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	# Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
.loop:
	# [num]&lt;&lt;=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+3
	# [rval]&lt;&lt;=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.shift  .shift  ?+1
	# Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0


uint.not:
	# Call  : 0 ? uint.not ret a
	#
	# Effect: [ret] = ~[a]
	#
	# Time  : 26
	#
	# Use the relation ~A=-1-A.
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.tmp    .p2:0   ?+1
	.tmp    .z+1    ?+1
	.ret    .ret    ?+1
	.ret    .tmp    ?+1
	.p1:0   .ret    ?+1
	# Return
	0       0       .arg4:4
	# Variables
	.z:0 1 2
	.tmp:0
	.ret:0


uint.and:
	# Call  : 0 ? uint.and ret a b
	#
	# Effect: [ret] = [a] &amp; [b]
	#
	# Time  : 37 + 7*bits = 485
	#
	# Make sure [a] and [b] are odd. Every loop, rotate [a] to the left and shift
	# [b] to the left. Depending on how the top bits of [a] and [b] are set, add 1
	# to [a]. Stop when [b]=0, and return [a]. Branches are organized in the loop
	# to minimize instructions.
	#
	# Use [0] to get the calling address.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	# Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	# Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	# Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	# so that we can efficiently check for carrying in the loop. Flag if the top bit
	# needs to be set at the end.
	        .atmp   .z+1    ?+1
	        .btmp   .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	# Loop until [b]=0.
.loop:
	# Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	# Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	# If [b]&lt;=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	# Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	# We have [a]=[a]&amp;[b]+-[btmp] and [btmp]=2^(n-1).
	.a      .ret0:0 ?+1
	.btmp   .a      ?+1
	.ret1:0 .btmp   ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0


uint.or:
	# Call  : 0 ? uint.or ret a b
	#
	# Effect: [ret] = [a] | [b]
	#
	# Time  : 38 + 7*bits = 486
	#
	# Use bitwise AND and the relation A|B=-1-(~A)&amp;(~B).
	#
	# Use [0] to get the calling address.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	# Get -[a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a      ?+1
	# Get -[b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.b      .b0:0   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b      ?+1
	# Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	# so that we can efficiently check for carrying in the loop. Flag if the top bit
	# needs to be set.
	        .a      .z+1    ?+1
	        .b      .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	# Loop until [b]=0.
.loop:
	# Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	# Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	# If [b]&lt;=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	# Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	# We have [a]=[a]&amp;[b]+-[btmp] and [btmp]=2^(n-1).
	# A|B=-1-(~A)&amp;(~B)
	.a      .z-1    ?+1
	.btmp   .ret0:0 ?+1
	.a      .btmp   ?+1
	.ret1:0 .a      ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0


uint.xor:
	# Call  : 0 ? uint.xor ret a b
	#
	# Effect: [ret] = [a] ^ [b]
	#
	# Time  : 39 + 7*bits = 487
	#
	# Use bitwise AND and the relation A^B=A+B-2(A&amp;B).
	#
	# Use [0] to get the calling address.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	# Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	# Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	# Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	# so that we can efficiently check for carrying in the loop.
	.off    .off    ?+1
	.off    .atmp   ?+1
	.off    .btmp   ?+1
	.atmp   .z+1    ?+1
	.btmp   .z+1    ?+1
	.a      .atmp   ?+1
	.b      .btmp   ?+1
	.atmp   .atmp   .loop
	# Loop until [b]=0.
.loop:
	# Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	# Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	# If [b]&lt;=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	# We have [a]=[a]&amp;[b]+-[off] and [off]=2^(n-1).
	# Use A^B=A+B-2(A&amp;B).
	.off    .a      ?+1
	.off    .ret0:0 ?+1
	.a      .off    ?+1
	.ret1:0 .a      ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0
	.off:0


#|==============================================================================


Signed Integer Library - v2.04

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


int.sico provides functions for performing the signed integer operations that
uint.sico doesn't cover.

If SICO's underlying integers are mod N, then we consider an integer to be
negative if x &gt;= floor((N+1)/2). The negative value of x is x' = x - N.

SICO typically uses integers modulo 2^64. However: string, integer arithmetic,
and comparison functions will work with any modulo. Bitwise functions, on the
other hand, require integers modulo 2^n.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |    Complexity     |  Instructions
                 |                   |   (64 bits)
     ------------+-------------------+----------------
        write    |  --               |     2317
         read    |  --               |     1472
          cmp    |  37               |       37
          min    |  43               |       43
          max    |  43               |       43
          abs    |  30               |       30
          mul    |  63 + 12.97*bits  |      893
          div    |  87 +  8.65*bits  |      640
          shr    |  43 +  8.00*bits  |      555


--------------------------------------------------------------------------------
Index


Strings
int.write [mem] [memlen] [memidx] retidx [num] [base] [sign]
int.read  [mem] [memlen] [memidx] retidx retnum [base] [sign]

Comparisons
int.cmp [a] [b] lt eq gt
int.min [ret] [a] [b]
int.max [ret] [a] [b]
int.abs [ret] [a]

Integer Arithmetic
int.mul [high] [low] [a] [b]
int.div [quot] [rem] [num] [den]

Bitwise Arithmetic
int.shr [ret] [num] [shift]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Most functions are based off of their unsigned equivalents.
1.01
     Added int.cmp, int.min, int.max, int.abs, int.mul, int.div, and int.shr.
1.02
     Removed a temporary variable in int.abs.
1.03
     Removed unnecessary instructions from int.mul when high=0.
2.00
     All integer arithmetic functions work with any modulo on the underlying
     integers.
     Remade int.div and int.mul to work with any modulo, even non power-of-two,
     by using the fibonacci sequence.
     int.div is 30% faster and int.mul is 1% faster.
2.01
     Updated comments.
2.02
     Replaced int.print with int.writestring.
     Added int.readstring.
2.03
     Replaced ASCII codes with ASCII literals.
2.04
     Renamed readstring/writestring to read/write so that the functions no
     longer imply that they work with string objects.


--------------------------------------------------------------------------------
TODO


Optimize sign extension for int.shr.
Optimize comparison functions.


|#


#---------------------------------------------------------------------------------
# Strings


int.write:
	# Call  : 0 ? int.write mem memlen memidx retidx num base sign
	#
	# Effect: Converts a signed integer to ASCII and writes it to memory.
	#       : [base] &lt;= 16
	#       : The first character is written to [mem]+[memidx].
	#       : The function does not write after [mem]+[memlen]-1 or if [mem]=0,
	#       : but [retidx] will still be updated.
	#       : [retidx] = [memidx] + (length of the ASCII string)
	#       : If [retidx]&gt;[memlen], then the string needs to be resized.
	#       : If retidx=0, then [retidx] is not written to.
	#       : If [sign]!=0, a plus sign will be printed for integers &gt;= 0.
	#       : Base = 0: c0*0^0 + c1*0^1 + c2*0^2 + ... = c0
	#       : Base = 1: c0*1^0 + c1*1^1 + c2*1^2 + ... = hash marks
	#       : Base &gt; 1: regular number
	#
	# Time  : Base = 0: 83
	#       : Base = 1: 92 + 9*MOD
	#       : Base &gt; 1: 77 + (23 + 6*base)*digits = 2317
	#       : digits = ceil(ln(MOD)/ln(base))
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	.arg8   0       ?+1
	.arg9   0       ?+1
	0       0       ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.mem    .mem    ?+1
	.mem    .tmp    ?+1
	# Get [memidx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nidx   .nidx   ?+1
	.nidx   .p4:0   ?+1
	# Get [memlen]. If [mem]=0 or [memlen]&lt;=[memidx], set [memlen]=0.
	.mem    .z      .len0
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.memlen .memlen ?+1
	.memlen .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .nidx   ?+1
	.memlen .tmp    .len0
	.memlen .z-1    ?+4
.len0:
	.memlen .memlen ?+1
	# Get retidx.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.p6     .p6     ?+1
	.p6     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p6:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	# Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg7:7 ?+1
	.p7     .p7     ?+1
	.p7     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p7:0   ?+1
	# Set string pointers.
	.nidx   .mem    ?+1
	.mem0   .mem0   ?+1
	.mem0   .nidx   ?+1
	.mem1   .mem1   ?+1
	.mem1   .nidx   ?+1
	.mem2   .mem2   ?+1
	.mem2   .nidx   ?+1
	.wret   .wret   ?+1
	# Make sure [base] &lt;= 16.
	.nbase  .z      .base0loop
	.base   .base   ?+1
	.base   .nbase  ?+1
	.base   .nbase  ?+1
	.nbase  .n17    .ret
	# Check if [num] &lt; 0.
	.wret   .wret0  ?+1
	.nnum   .z+1    ?+1
	.num    .nnum   .notneg
	# [num] &lt; 0. Set [nnum] = [num].
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.nnum   .tmp    ?+1
	.nchar  .minus  .write
.notneg:
	.nnum   .z-1    ?+1
	# Get [sign].
	.tmp    .tmp    ?+1
	.tmp    .arg8:8 ?+1
	.p8     .p8     ?+1
	.p8     .tmp    ?+1
	.p8:0   .z      .isneg
	.nchar  .plus   .write
.isneg:
	.num    .num    ?+1
	.num    .nnum   ?+1
	.nbase  .z15    .base1skip
.base1loop:
	# [base] = 1. Print hash marks.
	.num    .z      .ret
	.wret   .wretb1 ?+4
	.num    .z+1    .ret
	.nchar  .hex+2  .write
.base0loop:
	# [base] = 0. [char]=[num].
	.wret   .wretb0 ?+1
	.nchar  .num    .write
.base1skip:
	# Calculate the most significant digit and how many digits are in [num].
	.nbase  .nbase  ?+1
	.nbase  .base   ?+1
	.den    .den    ?+1
	.den    .z-1    ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.msdloop:
	.digits .z-1    ?+1
	.chr    .base   ?+1
	# Loop: num -= den
	.num    .den    .msddone
	.chr    .z-2    ?-5
	# den = den*base
	.nden   .nden   ?+1
	.nden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.num    .num    ?+1
	.num    .nnum   .msdloop
.msddone:
	# num += den if num&gt;0. If the original [num]=0, skip any correction.
	.nnum   .z      .nextloop-6
	.tmp    .tmp    ?+1
	.num    .z      ?+4
	.tmp    .den    ?+4
	.chr    .z-2    ?+4
	.num    .tmp    .msdloop+12
	.den    .den    ?+1
	.den    .nden   ?+1
	.base   .z+2    ?+1
	.chr    .nbase  ?+1
	.wret   .wret1  .nextwrite
.nextloop:
	.digits .z+1    .ret
	# digit = num/den
	.chr    .chr    ?+1
	.num    .den    ?+4
	.chr    .z-2    ?-5
	# num = num*base
	.num    .z      ?+7
	.num    .nden   ?+1
	.nnum   .nnum   ?+4
	.chr    .z-2    ?-5
	.z+1    .base   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.nextwrite:
	# Write a digit.
	.chr    .nhex   ?+1
	.nchar  .chr:0  .write
.write:
	# Mini function to write a character to the string.
	.memlen .z+1    .writeskip
	.mem0:0 .mem1:0 ?+1
	.mem2:0 .nchar  ?+1
	.mem2   .z-1    ?+1
	.mem1   .z-1    ?+4
.writeskip:
	.memlen .memlen ?+1
	.mem0   .z-1    ?+1
	.nchar  .nchar  .wret:0
.ret:
	# return [retidx] = [mem0] - [mem]
	.mem0   .ret0:0 ?+1
	.mem    .mem0   ?+1
	.ret1:0 .mem    ?+1
	0       0       .arg9:9
	# Variables
	0-2 0-1 .z:0 1 2
	.n17:0-17
	.z15:15
	.tmp:0
	.nnum:0
	.num:0
	.nbase:0
	.base:0
	.digits:0
	.den:0
	.nden:0
	.nchar:0
	.nidx:0
	.memlen:0
	.mem:0
	.plus:43
	.minus:45
	.hex:
		'0 '0 '1 '1 '2 '2 '3 '3 '4 '4 '5 '5 '6 '6 '7 '7
	     '8 '8 '9 '9 'a 'a 'b 'b 'c 'c 'd 'd 'e 'e 'f 'f
	.nhex:0-.hex
	.wret0:0-.isneg
	.wret1:.isneg-.nextloop
	.wretb0:0-.ret
	.wretb1:.isneg-.base1loop-6


int.read:
	# Call  : 0 ? int.readstring mem memlen memidx retidx retnum base
	#
	# Effect: Converts ASCII characters into a signed integer.
	#       : [base] &lt;= 36
	#       : [retnum] = return value.
	#       : The first character is read from [mem]+[memidx].
	#       : The function does not read after [mem]+[memlen]-1 or if [mem]=0,
	#       : but [retidx] will still be updated.
	#       : [retidx] = [memidx] + (number of read characters)
	#       : If retidx=0, then [retidx] is not written to.
	#
	# Time  : Base = 1: 110 + 19*MOD
	#       : Base &gt; 1: 128 + (17 + 2*base)*digits = 1472
	#       : digits = ceil(ln(MOD)/ln(base))
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	.arg8   0       ?+1
	0       0       ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.mem    .mem    ?+1
	.mem    .tmp    ?+1
	# Get [memidx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p4:0   ?+1
	.memidx .memidx ?+1
	.memidx .tmp    ?+1
	# Set string pointers.
	.tmp    .mem    ?+1
	.mem0   .mem0   ?+1
	.mem0   .tmp    ?+1
	# Get retidx.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get retnum.
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.ret2   .ret2   ?+1
	.ret2   .tmp    ?+1
	.ret3   .ret3   ?+1
	.ret3   .tmp    ?+1
	.num    .num    ?+1
	# Get [memlen]. If [mem]=0 or [memlen]&lt;=[memidx], return.
	.mem    .z      .ret+3
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.memlen .memlen ?+1
	.memlen .tmp    ?+1
	.memlen .memidx .ret+3
	.memlen .z-1    ?+1
	# Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg7:7 ?+1
	.p7     .p7     ?+1
	.p7     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p7:0   ?+1
	# Make sure [base] &lt;= 36.
	.rret   .rret   ?+1
	.nbase  .z      .base0loop
	.base   .base   .base0skip
.base0loop:
	.rret   .rret0  ?+1
	.char   .char   .read
	.num    .nchar  .ret+3
.base0skip:
	# [max]=[base]-1. If [base]=1, we allow [char] to be 0 or 1.
	.max    .max    ?+1
	.nbase  .z-2    ?+4
	.max    .z-1    .whiteloop
	.nbase  .z+1    ?+1
	.base   .nbase  ?+1
	.base   .nbase  ?+1
	.max    .nbase  ?+1
	.nbase  .n36    .ret+3
	# Read whitespace
.whiteloop:
	.rret   .rret1  ?+1
	.char   .char   .read
	.char   .z32    ?-5
	# Read any +- sign.
	.rret   .rret2  ?+1
	.char   .plus   ?+1
	.char   .z      .read
	.isneg  .z-1    ?+1
	.char   .minus  ?+1
	.char   .z      .read
	.isneg  .z+1    ?+1
	.char   .signc  ?+1
.signdone:
	.rret   .rret3  ?+1
.parseloop:
	# [char] &gt;= 'a'
	.char   .ca1    ?+4
	.char   .n9     .parsedone
	.char   .nca1   ?+1
	# [char] &gt;= 'A'
	.char   .cA1    ?+4
	.char   .n9     .parsedone
	.char   .ncA1   ?+1
	# [char] &gt;= '0'
	.nchar  .nc91   .ret
	.char   .c01    .ret
	.char   .z+1    ?+1
.parsedone:
	# If [char] &gt;= [max], abort.
	.nchar  .nchar  ?+1
	.nchar  .char   ?+1
	.char   .max    ?+4
	.mem    .z-1    .ret+3
	# num += num*(base-1)
	.z+1    .base   ?+4
	.tmp    .tmp    ?+13
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.z+1    .z-2    ?-5
	# num += char
	.num    .nchar  ?+1
	.char   .char   .read
.read:
	# Mini function to read a character from the string.
	.memlen .z+1    .ret+3
	.nchar  .nchar  ?+1
	.nchar  .mem0:0 ?+1
	.char   .nchar  ?+1
	.mem0   .z-1    .rret:0
.ret:
	# return [retidx] = [mem0] - [mem]
	.mem0   .z+1    ?+1
	.mem0   .ret0:0 ?+1
	.mem    .mem0   ?+1
	.ret1:0 .mem    ?+1
	# return [retnum]
	.isneg  .z      ?+10
	.isneg  .isneg  ?+1
	.isneg  .num    ?+1
	.num    .num    ?+1
	.tmp    .tmp    ?+1
	.num    .ret2:0 ?+1
	.tmp    .num    ?+1
	.tmp    .isneg  ?+1
	.isneg  .isneg  ?+1
	.ret3:0 .tmp    ?+1
	0       0       .arg8:8
	# Variables
	0-2 0-1 .z:0 1 2
	.n36:0-36
	.n9:0-9
	.z32:32
	.plus: '+ - ' 
	.minus:'- - '+
	.signc: 0 - '-
	.tmp:0
	.num:0
	.isneg:0
	.nbase:0
	.base:0
	.nchar:0
	.char:0
	.max:0
	.mem:0
	.memlen:0
	.memidx:0
	.rret0:0-.base0loop-6
	.rret1:0-.whiteloop-6
	.rret2:.whiteloop+6-.signdone
	.rret3:.signdone-.parseloop
	.ca1: 'a-1
	.nca1:1-'a
	.cA1: 'A-1
	.ncA1:1-'A
	.c01: '0-1
	.nc91:0-'9-1


#---------------------------------------------------------------------------------
# Comparisons


int.cmp:
	# Call  : 0 ? int.cmp a b lt eq gt
	#
	# Effect: For signed [a] and [b].
	#       : if [a]&lt;[b]: goto lt
	#       : if [a]=[b]: goto eq
	#       : if [a]&gt;[b]: goto gt
	#
	# Time  : 37
	#
	# Use [0] to get the calling address.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	# Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.na     .na     ?+1
	.na     .p0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	.na     .z+1    ?+1
	# Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .z      ?+1
	.nb     .nb     ?+1
	.nb     .p1:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	.nb     .z+1    ?+1
	.z      .z      ?+1
	# Check if [a]&gt;=0 or [b]&gt;=0.
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.na     .nb     .ge
.alt0bge0:
	# If [a]&lt;[b]
	.z      .arg4:4 .ret
.age0:
	.b      .nb     .age0bge0
.ge:
	.na     .z      .eq
.gt:
	# If [a]&gt;[b]
	.z      .arg6:6 .ret
.eq:
	# If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	# Variables
	.z:0 1 2
	.a:0
	.na:0
	.b:0
	.nb:0


int.min:
	# Call  : 0 ? int.min ret a b
	#
	# Effect: [ret] = min([a],[b]) for signed [a] and [b].
	#
	# Time  : 43
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .nb     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .na     .ret
.beq0:
	.nb     .z      ?-5
	.val    .nb     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .nb     .ret
.aeq0:
	.na     .z      ?-5
	.val    .na     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.max:
	# Call  : 0 ? int.max ret a b
	#
	# Effect: [ret] = max([a],[b]) for signed [a] and [b].
	#
	# Time  : 43
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	# Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .na     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .nb     .ret
.beq0:
	.nb     .z      ?-5
	.val    .na     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .na     .ret
.aeq0:
	.na     .z      ?-5
	.val    .nb     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.abs:
	# Call  : 0 ? int.abs ret a
	#
	# Effect: [ret] = abs([a])
	#
	# Time  : 30
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [val]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nval   .nval   ?+1
	.nval   .p0:0   ?+1
	.val    .val    ?+1
	.val    .nval   ?+1
	# Check if [val] &lt; 0.
	.tmp    .tmp    ?+1
	.nval   .z+1    ?+1
	.val    .nval   ?+4
	.tmp    .val    ?+4
	.nval   .z-1    ?+1
	# Set [ret].
	.tmp    .ret0:0 ?+1
	.nval   .tmp    ?+1
	.ret1:0 .nval   ?+1
	# Return
	0       0       .arg4:4
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.val:0
	.nval:0


#---------------------------------------------------------------------------------
# Integer Arithmetic


int.mul:
	# Call  : 0 ? int.mul high low a b
	#
	# Effect: [high] = [a]*[b] / MOD sign extended
	#       : [low]  = [a]*[b] % MOD
	#
	# Time  : 63 + 12.97*bits = 893
	# Time  : 47 +  7.21*bits = 508 if high=0
	#
	# Deconstruct [b] into a sum of fibonacci numbers (ex: 15=11+3+1). At the same
	# time, calculate [a]*[b] by building up a separate fibonacci sequence and adding
	# [a] to it every time a fibonacci number is a part of [b]'s sum.
	#
	# The actual time complexity is
	#
	#      n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#      time = 40 + 9*n(F)
	#      time = 34 + 5*n(F) if high=0
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    .firstrun
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	# Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	# Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	# Get -[b]. We will flip the sign of the result later.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .b0:0   ?+1
	.lval0  .lval0  ?+1
	.lval1  .lval1  ?+1
	# Get high. If [hret]=0, skip calculating the high value.
	.hret   .arg2:2 ?+1
	.hret   .z      .lowonly
	# ------- Calculate [lval] and [hval] --------
	.hval0  .hval0  ?+1
	.hval1  .hval1  ?+1
	.nb     .z      .highzero
	.na     .z      .highzero
	# Record [b] for sign correction.
	.b      .b      ?+1
	.b      .nb     ?+1
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .hstart:.highfib0+9
	# During each loop, fibonacci decrement the [nb]. If [nb]&gt;[fib], reduce [nb] and
	# add [a] to the return value. Then fibonacci increment the return value.
.highfib0:
	.fib1   .fib0   .highret
	.hval0  .hval1  ?+1
	# If [lval0]&lt;=[lval1], check for a carry into [hval0].
	.lval0  .lval1  .highfib1-6
	# If [nb]&gt;[fib0], add [a] to [lval0] and check for a carry into [hval0].
	.nb     .fib0   ?+16
	.lval0  .na     ?+7
	.hval0  .z+1    ?+1
	.nfib0  .nfib1  .highfib1
	.lval0  .z      ?-8
	.nfib0  .nfib1  .highfib1
	# [nb]&lt;=[fib0], so restore [nb].
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .highfib1
	# Checking for a carry from [lval0]-[lval1].
	.lval0  .z      .highfib0+9
	.hval0  .z-1    .highfib0+9
.highfib1:
	.fib0   .fib1   .highret
	.hval1  .hval0  ?+1
	# If [lval1]&lt;=[lval0], check for a carry into [hval1].
	.lval1  .lval0  .lowonly-6
	# If [nb]&gt;[fib1], subtract [a] from [lval1] and check for a carry into [hval1].
	.nb     .fib1   ?+13
	.lval1  .a      ?+4
	.nfib1  .nfib0  .highfib0
	.lval1  .z      ?-5
	.hval1  .z-1    ?-8
	# [nb]&lt;=[fib1], so restore [nb].
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .highfib0
	# Checking for a carry from [lval1]-[lval0].
	.lval1  .z      .highfib1+9
	.hval1  .z-1    .highfib1+9
	# ---------- Only calculate [lval] -----------
.lowonly:
	.nb     .z      .lowret+3
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .lstart:.lowfib0+6
	# During each loop, fibonacci decrement the [nb]. If [nb]&gt;[fib], reduce [nb] and
	# add [a] to the return value. Then fibonacci increment the return value.
.lowfib0:
	.fib1   .fib0   .lowret
	.lval0  .lval1  ?+1
	# If [nb]&gt;[fib0], add [a] to [lval0].
	.nb     .fib0   ?+7
	.lval0  .na     ?+1
	.nfib0  .nfib1  .lowfib1
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .lowfib1
.lowfib1:
	.fib0   .fib1   .lowret
	.lval1  .lval0  ?+1
	# If [nb]&gt;[fib1], subtract [a] from [lval1].
	.nb     .fib1   ?+7
	.lval1  .a      ?+1
	.nfib1  .nfib0  .lowfib0
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .lowfib0
	# -------------- Return values ---------------
.highret:
	# Calculate the low return value and subtract [a] from it.
	# Also check for final carries into the high value.
	.lval0  .lval1  ?+4
	.hval1  .z-1    ?+4
	.lval0  .z      ?-5
	.lval0  .na     ?+4
	.hval1  .z-1    ?+1
	.lval1  .lval1  ?+1
	# If [b]&gt;=0, add [a] to [hval].
	.nb     .nb     ?+1
	.nb     .b      ?+1
	.nb     .b      ?+4
	.hval0  .na     ?+1
	# If [a]&lt;0, subtract [b] from [hval].
	.na     .z+1    ?+1
	.a      .na     ?+4
	.hval0  .b      ?+1
.highzero:
	# Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.hval0  .h0:0   ?+1
	.hval1  .hval0  ?+1
	.h1:0   .hval1  ?+1
	.hret   .hret   .lowret+3
.lowret:
	# Set [low]
	.lval0  .na     ?+1
	.lval1  .l0:0   ?+1
	.lval0  .lval1  ?+1
	.l1:0   .lval0  ?+1
	# Return
	0       0       .arg6:6
	# On the first run, calculate the largest fibonacci values that can fit in our
	# underlying integers.
	.fdif:.firstrun-int.mul-3
	.hdif:.highfib0-.highfib1
	.ldif:.lowfib0-.lowfib1
.firstrun:
	int.mul+2 .fdif ?+1
	.nfib1i .fib0i  .firstset1
	.fib0i  .nfib1i ?-5
.firstset0:
	# If [fib0]&lt;[fib1], start on [fib1] loop.
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+1
	.nfib0i .fib0i  ?+1
	.hstart .hdif   ?+1
	.lstart .ldif   ?+1
	.fib1i  .z+1    ?+1
	.nfib1i .z-1    int.mul+3
.firstset1:
	.nfib0i .fib0i  ?+1
	.nfib1i .nfib0i ?+1
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+4
	.fib0i  .nfib1i .firstset1-6
	.nfib0i .nfib0i .firstset0+3
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.hret:0
	.hval0:0
	.hval1:0
	.lval0:0
	.lval1:0
	.fib0i:1
	.nfib0i:0
	.fib1i:0
	.nfib1i:0-1
	.fib0:0
	.nfib0:0
	.fib1:1
	.nfib1:0-1


int.div:
	# Call  : 0 ? int.div quot rem num den
	#
	# Effect: [quot] = [num] / [den] rounded down
	#       : [rem]  = [num] % [den]
	#
	# Time  : 87 + 8.65*bits = 640
	#       : 72 + 7.21*bits = 533 if quot=0
	#
	# Use the fibonacci sequence to build up [den]. Then run the sequence in
	# reverse to calculate [num]%[den]. While calculating the remainder, calculate
	# the quotient [num]/[den] by using another, separate fibonacci sequence.
	#
	# The actual time complexity is
	#
	#      n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#      time = 71 + 6*n(F)
	#      time = 58 + 5*n(F) if quot=0
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	# Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	# Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden1  .nden1  ?+1
	.nden1  .p1:0   ?+1
	# Get abs([den]).
	.qsign  .qsign  ?+1
	.den1   .den1   ?+1
	.den1   .nden1  ?+1
	.nden1  .z+1    ?+1
	.den1   .nden1  .denabs
	.tmp    .tmp    ?+1
	.tmp    .den1   ?+1
	.nden1  .tmp    ?+1
	.qsign  .z-1    ?+7
.denabs:
	.nden1  .z-1    ?+1
	# If [den]=0, abort.
	.nden1  .z      .divz
	# Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	# Get abs([num]).
	.tmp    .z+1    ?+1
	.num    .tmp    .numabs
	.rsign  .num    ?+1
	.tmp    .rsign  ?+1
	.qsign  .z+1    ?+4
.numabs:
	.tmp    .z-1    ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	# Get quot. If [qret]=0, skip calculating the quotient.
	.qret   .arg2:2 ?+1
	# If [den]*2&gt;=MOD, we need to skip calculating the largest multiple of [den].
	.den0   .nden1  ?+1
	.nden1  .den0   ?+4
	.den1   .den1   ?+7
	.den1   .den1   .denhalf
	# Calculate the largest fibonacci multiple of [den].
	.nden1  .den0   .denstart0
	.den0   .nden1  ?-5
.denstart1:
	# [den1]&gt;[den0]. Fill in the rest of the denominators.
	.den1   .nden1  ?+1
	.den0   .den1   ?+1
	.nden0  .den0   ?+1
	.qret   .z      .remden1+3
	.quot0  .quot0  .quotden1+6
.denstart0:
	# [den0]&gt;=[den1]. Fill in the rest of the denominators.
	# If [den0]=[den1], we need to swap values.
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.den0   .den1   ?+4
	.den0   .nden1  .denhalf+9
	.nden0  .nden0  .denstart1+3
.denhalf:
	# [den]*2&gt;=MOD. Manually set the denominators to +-[den].
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.qret   .z      .remden0+3
	.quot0  .quot0  .quotden0+6
	# -------- Calculate [rem] and [quot] --------
	# During each loop, fibonacci decrement the denominator and increment the
	# quotient. If [num]&gt;[den], reduce [num] and increment the quotient by 1.
.quotden0:
	.den1   .den0   .quotret
	.quot0  .quot1  ?+1
	# Test if [num]&gt;[den0].
	.num    .den0   ?+7
	.quot0  .z-1    ?+1
	.nden0  .nden1  .quotden1
	.num    .nden0  ?+1
	.nden0  .nden1  .quotden1
.quotden1:
	.den0   .den1   .quotret
	.quot1  .quot0  ?+1
	# Test if [num]&gt;[den1].
	.num    .den1   ?+7
	.quot1  .z+1    ?+1
	.nden1  .nden0  .quotden0
	.num    .nden1  ?+1
	.nden1  .nden0  .quotden0
	# ----------- Only calculate [rem] -----------
	# During each loop, fibonacci decrement the denominator. If [num]&gt;[den],
	# reduce [num].
.remden0:
	.den1   .den0   .remret
	# Test if [num]&gt;[den0].
	.num    .den0   ?+4
	.nden0  .nden1  .remden1
	.num    .nden0  ?+1
	.nden0  .nden1  .remden1
.remden1:
	.den0   .den1   .remret
	# Test if [num]&gt;[den1].
	.num    .den1   ?+4
	.nden1  .nden0  .remden0
	.num    .nden1  ?+1
	.nden1  .nden0  .remden0
	# -------------- Return values ---------------
.quotret:
	# Set [quot]. Because of how additions are split, return [quot0]-[quot1]+1.
	.num    .den1   ?+4
	.quot0  .z-1    ?+7
	.num    .z      ?-5
	.num    .nden1  ?+1
	# If the signs of [num] and [den] mismatch, negate the quotient.
	.qsign  .z      .quotflip
	.quot1  .quot0  ?+1
	.tmp    .tmp    ?+1
	.tmp    .quot1  ?+1
	.quot0  .quot0  ?+1
	.quot0  .tmp    ?+1
	.quot1  .quot1  ?+1
.quotflip:
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.quot0  .r0:0   ?+1
	.quot1  .quot0  ?+1
	.r1:0   .quot1  ?+1
	.quot1  .quot1  ?+1
	.qret   .qret   .remret+9
.remret:
	# Set [rem].
	.num    .den1   ?+1
	.num    .z      ?+4
	.num    .nden1  ?+1
	# If [num]&lt;0, negate [rem].
	.tmp    .tmp    ?+1
	.rsign  .z      .remflip
	.rsign  .rsign  ?+1
	.rsign  .num    ?+1
	.num    .num    ?+1
	.tmp    .rsign  ?+1
	.rsign  .rsign  ?+1
.remflip:
	.num    .r2:0   ?+1
	.tmp    .num    ?+1
	.r3:0   .tmp    ?+1
	# Return
	0       0       .arg6:6
.divz:
	# Division by 0. Abort.
	0-1     0       ?-2
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den0:0
	.nden0:0
	.den1:0
	.nden1:0
	.qret:0
	.quot0:0
	.quot1:0
	.qsign:0
	.rsign:0


#---------------------------------------------------------------------------------
# Bitwise Arithmetic


int.shr:
	# Call  : 0 ? int.shr ret num shift
	#
	# Effect: [ret] = [num] &gt;&gt; [shift]. Sign extend if [num]&lt;0.
	#
	# Time  : 43 + 8*bits = 555
	#
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	# Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	# Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	# Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
	# If [num]&lt;0, set [tmp]=~[num].
	.num    .tmp    .numpos
	.neg    .num    ?+1
	.tmp    .neg    ?+1
.numpos:
	# If [shift]&gt;=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	.num    .num    ?+1
	.num    .tmp    ?+1
	.num    .z+1    ?+1
.loop:
	# [num]&lt;&lt;=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+6
	# [rval]&lt;&lt;=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.tmp    .tmp    ?+1
	.shift  .shift  ?+1
	# If [num]&lt;0, set [rval]=~[rval].
	.neg    .z      .notneg
	.neg    .neg    ?+1
	.num    .num    ?+1
	.num    .rval   ?+1
	.tmp    .num    ?+1
	.tmp    .z-1    ?+1
	.rval   .rval   ?+1
.notneg:
	# Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	# Return
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.neg:0


#|==============================================================================


Random Number Generator Library - v2.00

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


random.sico provides functions for generating uniform random numbers.


--------------------------------------------------------------------------------
Index


random.hash    [ret] [num]
random.seed    [num]
random.jump    [num]
random.get     [ret]
random.mod     [ret] [mod]
random.shuffle [[arr]] [len]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
1.01
     Added shuffling.
1.02
     Optimized random.generate by removing offsets during shitfing.
1.03
     Initial seed is generate by system time.
1.04
     Optimized jump, mod, and shuffle and made them bit length agnostic.
     Merged random.generate and random.get.
     Added random.init to initialize random.get and seed using current time.
1.05
     Added random.hash.
1.06
     Performed testing on rejection sampling for various integer ranges.
     Accepting "rand-(rand%mod)&lt;=-mod" works for any underlying integers.
2.00
     Remade PRNG to work with any underlying integers.


--------------------------------------------------------------------------------
PRNG Overview


The PRNG works by incrementing the state, hashing it, and returning the result.
The hash function has the following form:


     tmp=-1-hash
     hash-=tmp
     if GT:
          tmp=-hash
          hash-=tmp
          if GT: hash-=con3
          else : hash-=con2
     else:
          tmp=-hash
          hash-=tmp
          if GT: hash-=con1
          else : hash-=con0


The ideal number of iterations for the hash function is ceil(log2(mod)/2).

The formulas below provide a way to calculate the constants (con0, con1, ...)
so that the function provides a full mapping, depending on the modulus of our
underlying integers modulo 4.

If mod % 4 = 0, for instance, we would pick a random value (A), and choose
one of the six forms listed below to give us con0, con1, con2, and con3.

The best performers were selected by comparing avalanche and differential
effects.

if mod % 4 = 0:

     A, B, C, D
     A%4 != B%4 != C%4 != D%4

     best: A%4 = 0, B%4 = 2, C%4 = 1, D%4 = 3

if mod % 4 = 1:

     A+0, A-3, A+1, A+2
     A+0, A-3, A+3, A+0
     A+0, A-2, A+0, A+2
     A+0, A-2, A+3, A-1
     A+0, A+0, A+0, A+0
     A+0, A+0, A+1, A-1

     best: A+0, A-2, A+3, A-1

if mod % 4 = 2:

     A, B, B, A
     A, A, B, B
     A%2 != B%2

     best: A%2 = 0, B%2 = 1, B%2 = 1, A%2 = 0

if mod % 4 = 3:

     A+0, A-2, A+1, A-3
     A+0, A-1, A+1, A+0
     A+0, A+0, A-1, A-3
     A+0, A+0, A+0, A+0

     best: A+0, A-2, A+1, A-3

The increment for the PRNG can be found by randomly selecting a value relatively
prime to the modulus in ~ln(ln(mod)) GCD operations. We can do this by testing:

     while gcd(add,-add)!=1: add=rand()


--------------------------------------------------------------------------------
TODO


Figure out better constants for mod%4 = 1 or 3.
See if there are better seeding algorithms.


|#


random.init:
	# Get the current and original calling addresses.
	.orig   .0      ?+1
	.0      .0      ?+1
	.0      0       ?+1
	0       0       ?+1
	# Make sure we only initialize once.
	random.seed   +2 .z-3 ?+1
	random.hash   +2 .z-3 ?+1
	random.get    +2 .z-3 ?+1
	random.jump   +2 .z-3 ?+1
	# Set i to the number of iterations we need properly hash our values.
	# i~=ceil(log2(mod)/2) has the best hashing characteristics.
	.mul    .mul    ?+1
	.mul    .z+1    .idone-3
.iloop:
	.i      .z-1    ?+1
	.tmp    .mul    ?+1
	.mul    .tmp    .idone
	.tmp    .tmp    ?+1
	.tmp    .mul    ?+1
	.mul    .tmp    .idone
	.tmp    .tmp    .iloop
.idone:
	# Set .get and .hash iteration counters.
	random.hash.iters .i ?+1
	random.get.iters  .i ?+1
	# Reset the PRNG state.
	random.get.state random.get.state ?+1
	random.get.inc   random.get.inc   ?+1
	random.get.inc   .z+1             ?+1
	# Set the PRNG constants based on the modulus % 4.
	0 ? uint.div 0 .mod .mod .z+4
	.i      .z-1    ?+1
.conloop:
	# Set random.get's constants.
	random.get.con0 random.get.con0 ?+1
	random.get.con0 .con0           ?+1
	random.get.con1 random.get.con1 ?+1
	random.get.con1 .con1           ?+1
	random.get.con2 random.get.con2 ?+1
	random.get.con2 .con2           ?+1
	random.get.con3 random.get.con3 ?+1
	random.get.con3 .con3           ?+1
	.i      .z+1    .condone
	.con0   .con0   ?+1
	.con1   .con1   ?+1
	.con2   .con2   ?+1
	.con3   .con3   ?+1
	.mod    .z      .mod1
	.mod    .z+1    .mod2
	.mod    .z+1    .mod3
.mod0:
	# A%4 = 0, B%4 = 2, C%4 = 1, D%4 = 3
	0 ? random.get .tmp
	.con0   .tmp    ?+1
	.con0   .tmp    ?+1
	.con0   .tmp    ?+1
	.con0   .tmp    ?+1
	0 ? random.get .tmp
	.con1   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .z+2    ?+1
	0 ? random.get .tmp
	.con2   .tmp    ?+1
	.con2   .tmp    ?+1
	.con2   .tmp    ?+1
	.con2   .tmp    ?+1
	.con2   .z+1    ?+1
	0 ? random.get .tmp
	.con3   .tmp    ?+1
	.con3   .tmp    ?+1
	.con3   .tmp    ?+1
	.con3   .tmp    ?+1
	.con3   .z+3    ?+1
	.mod    .z-3    .conloop
.mod1:
	# A+0, A-2, A+3, A-1
	0 ? random.get .tmp
	.con0   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .z-2    ?+1
	.con2   .tmp    ?+1
	.con2   .z+3    ?+1
	.con3   .tmp    ?+1
	.con3   .z-1    ?+1
	.mod    .z      .conloop
.mod2:
	# A%2 = 0, B%2 = 1, B%2 = 1, A%2 = 0
	0 ? random.get .tmp
	.con0   .tmp    ?+1
	.con0   .tmp    ?+1
	.con3   .tmp    ?+1
	.con3   .tmp    ?+1
	0 ? random.get .tmp
	.con1   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .z+1    ?+1
	.con2   .tmp    ?+1
	.con2   .tmp    ?+1
	.con2   .z+1    ?+1
	.mod    .z-1    .conloop
.mod3:
	# A+0, A-2, A+1, A-3
	0 ? random.get .tmp
	.con0   .tmp    ?+1
	.con1   .tmp    ?+1
	.con1   .z-2    ?+1
	.con2   .tmp    ?+1
	.con2   .z+1    ?+1
	.con3   .tmp    ?+1
	.con3   .z-3    ?+1
	.mod    .z-2    .conloop
.condone:
	# Set random.hash's constants to the same as random.get.
	random.hash.con0 random.hash.con0 ?+1
	random.hash.con0 .con0            ?+1
	random.hash.con1 random.hash.con1 ?+1
	random.hash.con1 .con1            ?+1
	random.hash.con2 random.hash.con2 ?+1
	random.hash.con2 .con2            ?+1
	random.hash.con3 random.hash.con3 ?+1
	random.hash.con3 .con3            ?+1
	# Seed the generator with the system time.
	0 ? random.seed 0-5
	# Return to the calling function.
	0       .0      .orig:0-4
	# Variables
	0-3 0-2 0-1 .z:0 1 2 3 4
	.0:0
	.tmp:0
	.mul:0
	.i:0
	.mod:0-1
	# Start with values that are decent across different mods.
	.con0:0-1
	.con1:0-0
	.con2:0+1
	.con3:0+2


random.hash:
	# Call  : 0 ? random.hash ret num
	# Effect: [ret] = a hash of [num]
	# Time  : 26 + 4.5*bits = 314
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.hash   .hash   ?+1
	.hash   .p0:0   ?+1
	# Hash [val].
	.tmp    .tmp    ?+1
	.i      .iters  ?+4
.loop:
	.i      .z+1    .done
	        .tmp    .z+1    ?+1
	        .tmp    .hash   ?+1
	.fxx:   .hash   .tmp    .f0x
	.f1x:   .tmp    .tmp    ?+1
	        .tmp    .hash   ?+1
	        .hash   .tmp    .f10
	.f11:   .hash   .con3   ?+1
	        .tmp    .tmp    .loop
	.f10:   .hash   .con2   ?+1
	        .tmp    .tmp    .loop
	.f0x:   .tmp    .tmp    ?+1
	        .tmp    .hash   ?+1
	        .hash   .tmp    .f00
	.f01:   .hash   .con1   ?+1
	        .tmp    .tmp    .loop
	.f00:   .hash   .con0   ?+1
	        .tmp    .tmp    .loop
.done:
	# Set [ret] and return.
	.hash   .ret0:0 ?+1
	.tmp    .hash   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg4:4
	# Variables
	.z:0 1 2
	.tmp:0
	.hash:0
	.i:0
	# The hash function state.
	.iters:0
	.con0:0+1
	.con1:0+0
	.con2:0-1
	.con3:0-2


random.seed:
	# Call  : 0 ? random.seed num
	# Effect: Sets the PRNG state based on the value of [num].
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	0       .z+2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	# Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .p0:0   ?+1
	# Reset the generator state.
	random.get.state random.get.state ?+1
	random.get.state .num             ?+1
	random.get.inc   random.get.inc   ?+1
	random.get.inc   .z+1             ?+1
	# Generate a random increment relatively prime to the modulus.
	# If gcd(num,-num)=1, then it's relatively prime.
	.tmp    .tmp    ?+1
.incloop:
	0 ? random.get .num
	.tmp    .num    ?+1
	0 ? uint.gcd .tmp .tmp .num
	.tmp    .z+1    ?+1
	.tmp    .z      .incdone
	.tmp    .tmp    .incloop
.incdone:
	# Set [state].
	random.get.inc   random.get.inc   ?+1
	random.get.inc   .num             ?+1
	.num    .num    .arg3:3
	# Variables
	.z:0 1 2
	.tmp:0
	.num:0


random.jump:
	# Call  : 0 ? random.jump num
	# Effect: Jumps the PRNG state forward or backwards [num] number of steps.
	# Time  : 62 + 7.21*bits = 523
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	0       .z+2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	# Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	# [state]+=[inc]*[num]
	0 ? uint.mul 0 .mul .num:0 random.get.inc
	.tmp    .tmp    ?+1
	.tmp    .mul    ?+1
	random.get.state .tmp ?+1
	# Return
	0       0       .arg3:3
	# Variables
	.z:0 1 2
	.tmp:0
	.mul:0


random.get:
	# Call  : 0 ? random.get ret
	# Effect: [ret] = a uniform random number
	# Time  : 21 + 9*ceil(bits/2) = 309
	# Time  :  8 + 9*ceil(bits/2) = 296 for reentry
	# Use [0] to get the calling address.
	.hash   .hash   ?+1
	random.init.0 ? random.init
	.hash   .arg2   ?+1
	0       .hash   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	# Get ret.
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.hash   .hash   ?+1
	.hash   .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .hash   ?+1
.reenter:
	# Advance the PRNG state.
	.state  .inc    ?+1
	.hash   .hash   ?+1
	.hash   .state  ?+1
	# Hash the state.
	.i      .iters  ?+4
.loop:
	.i      .z+1    .done
	        .tmp    .z+1    ?+1
	        .tmp    .hash   ?+1
	.fxx:   .hash   .tmp    .f0x
	.f1x:   .tmp    .tmp    ?+1
	        .tmp    .hash   ?+1
	        .hash   .tmp    .f10
	.f11:   .hash   .con3   ?+1
	        .tmp    .tmp    .loop
	.f10:   .hash   .con2   ?+1
	        .tmp    .tmp    .loop
	.f0x:   .tmp    .tmp    ?+1
	        .tmp    .hash   ?+1
	        .hash   .tmp    .f00
	.f01:   .hash   .con1   ?+1
	        .tmp    .tmp    .loop
	.f00:   .hash   .con0   ?+1
	        .tmp    .tmp    .loop
.done:
	# Set [ret] and return.
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .hash   ?+1
	0       0       .arg3:3
	# Variables
	.z:0 1 2
	.tmp:0
	.hash:0
	.i:0
	# The PRNG state.
	.iters:0
	.state:0
	.inc:0-1
	.con0:0+1
	.con1:0+0
	.con2:0-1
	.con3:0-2


random.mod:
	# Call  : 0 ? random.mod ret mod
	# Effect: [ret] = a uniform random number in [0,[mod])
	# Time  : 63 + 8.42*bits = 601
	# Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	# Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [mod].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nmod   .nmod   ?+1
	.nmod   .p0:0   ?+1
	.mod    .mod    ?+1
	.mod    .nmod   ?+1
	# Perform rejection sampling until we satisfy rand-(rand%mod)&lt;=-mod.
	# Return rand%mod.
	0 ? random.get .rand
	0 ? uint.div 0 .ret0:0 .rand .mod
	.rand   .ret1:0 ?+1
	.rand   .nmod   .arg4:4
	.tmp    .tmp    random.get.reenter
	# Variables
	.z:0 1 2
	.tmp:0
	.rand:0
	.mod:0
	.nmod:0


random.shuffle:
	# Call  : 0 ? random.shuffle arr len
	# Effect: Randomly shuffles [[arr]] from [0,[len]).
	# Use [0] to get the calling address.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .z+2    ?+1
	0       .tmp0   ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	# Get [len]. If [len]&lt;=1, return.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .p1:0   ?+1
	.len    .len    ?+1
	.len    .tmp0   ?+1
	.len    .z+1    .done
	# Get -[arr].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.narr   .narr   ?+1
	.narr   .p0:0   ?+1
	# Set array pointers.
	.i0     .i0     ?+1
	.i0     .narr   ?+1
	.i1     .i1     ?+1
	.i1     .narr   ?+1
	# Use the Fisher-Yates shuffling algorithm.
.loop:
	# Set j=arr+[rand]%(i+1).
	0 ? random.mod .j0 .z+2
	.j0     .narr   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .j0     ?+1
	.j1     .j1     ?+1
	.j1     .tmp0   ?+1
	# Increment i.
	.i0     .z-1    ?+1
	.i1     .z-1    ?+1
	# Swap [i] and [j].
	.tmp0   .tmp0   ?+1
	.tmp0   .i0:0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .j0:0   ?+1
	# [tmp1]=[i]-[j]
	.tmp1   .tmp0   ?+1
	.i1:0   .tmp1   ?+1
	# [tmp0]=[j]-[i]
	.tmp0   .tmp0   ?+1
	.tmp0   .tmp1   ?+1
	.j1:0   .tmp0   ?+1
	# Next loop.
	.len    .z+1    .done
	random.mod.nmod .z+1 ?+1
	random.mod.mod  .z-1 random.get.reenter
.done:
	0       0       .arg4:4
	# Variables
	0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.narr:0
	.len:0

#|==============================================================================


String Library - v2.03

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


string.sico provides functions for basic string manipulation and console IO.

Do not include this library first. It needs to start at address 256 or later for
the escape code constants to work.

This library depends on the memory and math libraries.


--------------------------------------------------------------------------------
Index


String Structure
     0 len
     1 ptr
     char[i] = [[ptr] + [i]]

Management
     string.create   [ret]
     string.free     [str]

Comparisons

Formatting
     string.writeinline [ret] char0 char1 char2 ... 0

Input/Output
     string.print char0 char1 char2 ... 0
     string.input [ret]

Block Operations

Padding

String formatting escape codes:
     string.str      [str]
     string.strfmt   [str], [padding], [pad char]
     string.strinl   [str],  padding ,  pad char
     string.uint     [num]
     string.uintfmt  [num], [base], [padding], [pad char]
     string.uintinl  [num],  base ,  padding ,  pad char
     string.int      [num]
     string.intfmt   [num], [base], [padding], [pad char], [sign]
     string.intinl   [num],  base ,  padding ,  pad char ,  sign


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Created print function.
1.01
     Reorganized integer printing constants.
1.02
     Replaced built-in integer printing with uint.print and int.print.
     Library now handles strings instead of just printing.
1.03
     Renamed print to string.print for consistency.
1.04
     Updated comments.
1.05
     Modified string.print to use uint.writestring instead of uint.print.
2.00
     Added string structure, basic manipulation functions, and console
     input/output functions.
2.01
     Updated string structure so [len] is at index 0.
     Added string.writeinline and string.input.
     Modified string.print to use string.writeinline.
2.02
     Renamed uint.writestring to uint.write.
2.03
     Corrected reallocation in string.input.


--------------------------------------------------------------------------------
ASCII Reference Table


      0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
      1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
      2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
      3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
      4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
      5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
      6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
      7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
      8  08  BCK |  34  22   "  |  60  3c   &lt;  |  86  56   V  | 112  70   p
      9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
     10  0a  LF  |  36  24   $  |  62  3e   &gt;  |  88  58   X  | 114  72   r
     11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
     12  0c      |  38  26   &amp;  |  64  40   @  |  90  5a   Z  | 116  74   t
     13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
     14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
     15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
     16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
     17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
     18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
     19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
     20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
     21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
     22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
     23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
     24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
     25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |


--------------------------------------------------------------------------------
TODO


Management
     string.copy     ret str
     string.clear    str
     string.length   ret str
     string.getchar  ret str idx
     string.setchar  str idx chr

Comparisons
     string.cmp      a b lt eq gt

Block Operations
     string.substring ret str start stop
     string.split    ret str

Padding
     string.strip    ret str
     string.padleft  ret str
     string.padright ret str
     string.padsign  ret str # pad's left but skips +-, so "-31" becomes "-0031"

writeinline
	Rename from 'writeinline' to 'write'?
	If padlen&lt;0, pad right instead.
	Merge escstr with padding loop.
	Optimize setting ret attributes.

input
	Optimize setting ret attributes.


|#


#---------------------------------------------------------------------------------
# Constants


# The string structure in memory.
# Place [len] first so null pointers are treated as 0-length strings.
string.struct:
	.len:  0
	.ptr:  1
	.size: 2


# Escape codes. Used to insert values into strings.
string.escstart:
string.str:     0  # [str]
string.strfmt:  1  # [str], [padding], [pad char]
string.strinl:  2  # [str],  padding ,  pad char
string.uint:    3  # [num]
string.uintfmt: 4  # [num], [base], [padding], [pad char]
string.uintinl: 5  # [num],  base ,  padding ,  pad char
string.int:     6  # [num]
string.intfmt:  7  # [num], [base], [padding], [pad char], [sign]
string.intinl:  8  # [num],  base ,  padding ,  pad char ,  sign
string.escend:


#---------------------------------------------------------------------------------
# Management


string.create:
	# Call  : 0 ? string.create ret
	# Effect: Allocates an empty string and returns its pointer.
	mem.getargs.0 ? mem.getargs .ret 0 .arg3 0 0
	0 ? mem.alloc .str string.struct.size
	0 ? mem.set .ret:0 .str
	0 0 .arg3:0
	# Variables
	.str:0


string.free:
	# Call  : 0 ? string.free str
	# Effect: Frees [str].
	mem.getargs.0 ? mem.getargs .str 2 .arg3 0 0
	0 ? mem.getidx .strptr .str string.struct.ptr
	0 ? mem.free .strptr
	0 ? mem.free .str
	0 0 .arg3:0
	# Variables
	.strptr:0
	.str:0


#---------------------------------------------------------------------------------
# Formatting


string.writeinline:
	# Call  : 0 ? string.writeinline [ret] char0 char1 char2 ... 0
	#
	# Effect: Writes a zero terminated ASCII string to [ret]. If an escape code is
	#       : used, the next value(s) are expected to be numbers or formatting.
	#       : [ret] needs to be a string.
	#
	# Use [0] to get the calling address.
	0       .z+2    ?+1
	.arg2   .arg2   ?+1
	.arg2   0       ?+1
	0       .z+1    ?+1
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	0       0       ?+1
	.retry  .retry0 .writeloop
.ret:
	.memrem .memrem ?+1
	.nchar
.writeloop:
	# Get the next character.
	.nchar  .ptr:0  ?+1
	.ptr    .z-1    ?+1
	# If -[char]&lt;=[escape], then we want to print a non-character or escape.
	.nchar  .esc    .escprint
	.nchar  .nesc   ?+1
	# Print [char].
	.memrem .z+1    .resize
	.mem:0  .nchar  ?+1
	.mem    .z-1    ?+1
	.nchar  .nchar  .writeloop
.escprint:
	# Print something other than a character. Also check if [char]=0.
	.retry  .retry  ?+1
	.nchar  .vesc   .escinvalid
	0       .ptr    ?+1
	0       .z-2    ?+1
	.padchr .padchr ?+1
	.padchr .paddef ?+1
	.nchar  .z+1    .escintinl
	.nchar  .z+1    .escintfmt
	.nchar  .z+1    .escint
	.nchar  .z+1    .escuintinl
	.nchar  .z+1    .escuintfmt
	.nchar  .z+1    .escuint
	.nchar  .z+1    .escstrinl
	.nchar  .z+1    .escstrfmt
	.nchar  .z+1    .escstr
.escinvalid:
	# If [char]=0, we've reached the end of the string.
	.nchar  .zesc   ?+1
	.nchar  .z      .done
	# Print "INVALID FORMAT" and abort.
	.ilen   .z+1    .z-1
	0-2     .iptr   ?+1
	?-2     .z-1    .escinvalid
	.iptr: 'I 'N 'V 'A 'L 'I 'D '  'F 'O 'R 'M 'A 'T 10
	.ilen: .ilen-.iptr+1
.escstr:
	mem.getargs.0 ? mem.getargs .tmp 2 .ptr 0 0
	0 ? mem.getidx .retlen .tmp string.struct.len
	0 ? mem.getidx .stmp   .tmp string.struct.ptr
	.nres   .nres   ?+1
	.nres   .retlen ?+1
	.retry  ?+2     ?+2  0-?-1
	.memrem .retlen .resize+12
	0 ? mem.copy .mem .stmp .retlen
	.tmp    .tmp    .escchecklen+6
	.stmp:0
.escstrfmt:
	mem.getargs.0 ? mem.getargs .tmp 2 .padlen 2 .padchr 2 .ptr 0 0
	.nres   .nres   .escstr+8
.escstrinl:
	mem.getargs.0 ? mem.getargs .tmp 2 .padlen 1 .padchr 1 .ptr 0 0
	.nres   .nres   .escstr+8
.escuint:
	mem.getargs.0 ? mem.getargs ?+16 1 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? uint.write .mem .memrem .z .retlen 0 .base
	.nres   .nres   .escchecklen
.escuintfmt:
	mem.getargs.0 ? mem.getargs ?+22 1 ?+21 1 .padlen 2 .padchr 2 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? uint.write .mem .memrem .z .retlen 0 0
	.nres   .nres   .escchecklen
.escuintinl:
	mem.getargs.0 ? mem.getargs ?+22 1 ?+21 0 .padlen 1 .padchr 1 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? uint.write .mem .memrem .z .retlen 0 0
	.nres   .nres   .escchecklen
.escint:
	mem.getargs.0 ? mem.getargs ?+16 1 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? int.write .mem .memrem .z .retlen 0 .base .z
	.nres   .nres   .escchecklen
.escintfmt:
	mem.getargs.0 ? mem.getargs ?+24 1 ?+23 1 .padlen 2 .padchr 2 ?+18 1 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? int.write .mem .memrem .z .retlen 0 0 0
	.nres   .nres   .escchecklen
.escintinl:
	mem.getargs.0 ? mem.getargs ?+24 1 ?+23 0 .padlen 1 .padchr 1 ?+18 0 .ptr 0 0
	.retry  ?+2     ?+2  0-?-1
	0 ? int.write .mem .memrem .z .retlen 0 0 0
	.nres   .nres   .escchecklen
.escchecklen:
	# If we had enough space in the string, resume parsing.
	.nres   .retlen ?+1
	.memrem .retlen .resize+6
	.mem    .nres   ?+1
	# If we need to add padding, shift the escape string and add padding, so
	# [str]+[escstr] becomes [str]+[pad]+[escstr].
	.padlen .retlen .escpaddone
	.retry  .retry  ?+1
	.retry  .retry1 ?+1
	.nres   .nres   ?+1
	.nres   .padlen ?+1
.escpadstart:
	.memrem .padlen .resize+9
	# Set string pointers.
	.tmp    .tmp    ?+1
	.tmp    .mem    ?+1
	.pad3   .pad3   ?+1
	.pad3   .tmp    ?+1
	.mem    .nres   ?+1
	.tmp    .padlen ?+1
	.pad0   .pad0   ?+1
	.pad0   .tmp    ?+1
	.pad1   .pad1   ?+1
	.pad1   .tmp    ?+1
	.pad2   .pad2   ?+1
	.pad2   .tmp    ?+1
	.pad2+2 .z18    ?+1
	.padlen .z-1    ?+1
	.retlen .z-1    ?+1
.escpadloop:
	.tmp    .tmp    ?+1
	.retlen .z+1    ?+7
	.pad3   .z+1    ?+1
	.tmp    .pad3:0 ?+10
	.pad2+2 .n18    ?+1
	.tmp    .padchr ?+1
	.padlen .z+1    .escpaddone+6
	.pad0   .z+1    ?+1
	.pad1   .z+1    ?+1
	.pad2   .z+1    ?+1
	.pad0:0 .pad1:0 ?+1
	.pad2:0 .tmp    .escpadloop+18
.escpaddone:
	.padlen .padlen ?+1
	.retlen .retlen ?+1
	.retry  .retry  ?+1
	.retry  .retry0 .writeloop
.resize:
	# Double the size of our string until [memlen]&gt;=[retlen].
	.nres   .nres   ?+1
	.memrem .z      .mem            # regular character
	.memrem .z      .escchecklen+6  # esc resize
	.memrem .z      .escpadstart+3  # esc padding
	.memrem .z      .escstrfmt-10   # string printing
	.reslen .reslen ?+1
	.reslen .nres   ?+1
.resizeloop:
	.memrem .z      .resizedone
	.memrem .nres   ?+1
	.tmp    .tmp    ?+1
	.memlen .z      ?+4
	.tmp    .memlen ?+4
	.tmp    .z16    ?+1
	.memlen .tmp    ?+1
	.memrem .tmp    ?+1
	.memrem .reslen .resizeloop
.resizedone:
	.memrem .nres   ?+1
	.mem    .mem0   ?+1
	0 ? mem.realloc .mem0 .mem0 .memlen
	.tmp    .tmp    ?+1
	.tmp    .mem0   ?+1
	.mem    .tmp    ?+1
	.tmp    .tmp    .retry:0
.done:
	# Set [ret].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1:0 ?+1
	.ret2   .ret2   ?+1
	.ret2   .tmp    ?+1
	.memlen .memrem ?+1
	0 ? mem.setidx .ret2 string.struct.len .memlen
	0 ? mem.getidx .mem .ret2 string.struct.ptr
	0 ? mem.free .mem
	0 ? mem.setidx .ret2 string.struct.ptr .mem0
	.mem    .mem    ?+1
	.mem0   .mem0   ?+1
	.memlen .memlen .ret
	# Variables
	0-2 0-1 .z:0 1 2
	.n18:0-18
	.z16:16
	.z18:18
	.tmp:0
	.esc:0-256
	.nesc:256
	.vesc:256-string.escend
	.zesc:string.escend
	.nchar:0
	.mem0:0
	.memlen:0
	.memrem:0
	.retlen:0
	.retry0:0-.mem
	.retry1:0-.escpadstart
	.nres:0
	.reslen:0
	.ret2:0
	# Formatting defaults
	.base:10
	.padlen:0
	.padchr:0
	.paddef:0-' 


#---------------------------------------------------------------------------------
# Input/Output


string.print:
	# Call  : 0 ? string.print char0 char1 char2 ... 0
	#
	# Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#       : the next value(s) are expected to be numbers or formatting.
	#
	# Use [0] to get the calling address.
	0       .z+2    ?+1
	string.writeinline.ret+2 .wset0 ?+1
	string.writeinline.arg2 string.writeinline.arg2 ?+1
	string.writeinline.arg2 .str1 string.writeinline+12
.reenter:
	string.writeinline.ret+2 .wset1 ?+1
	.len    .z      .printdone
	.z      .ptr    ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      .printloop+3
.printloop:
	.len    .z+1    .printdone
	0-2     .p0:0   ?+1
	.p0     .z-1    .printloop
.printdone:
	0 ? mem.free .ptr
	.ptr    .ptr    string.writeinline.ret+3
	# Variables
	0-1 .z:0 1 2
	.wset0:string.writeinline.ret+3-.reenter
	.wset1:.reenter-string.writeinline.ret-3
	.str1:0-.str0
	.str0:.str
	.str:?+1 .len:0 .ptr:0


string.input:
	# Call  : 0 ? string.input ret
	#
	# Effect: Reads input from stdin until an EOL.
	#       : [ret] needs to be a string.
	#
	# Use [0] to get the calling address.
	0       .z+2    ?+1
	.arg2   .arg2   ?+1
	.arg2   0       ?+1
	0       .z+1    ?+1
	.arg3   .arg3   ?+1
	.arg3   0       ?+1
	0       0       ?+1
	# Reset our working memory.
	.mem    .mem    ?+1
	.mem0   .mem0   ?+1
	.memlen .memlen ?+1
	.memrem .memrem ?+1
	.memrem .z-1    .loop+3
.loop:
	# Read the next character until an EOL.
	.nchar  .nchar  ?+1
	.nchar  0-3     ?+1
	.nchar  .neol   ?+1
	.nchar  .z      .done
	.nchar  .eol    ?+1
	.memrem .z+1    .resize
	.mem:0  .nchar  ?+1
	.mem    .z-1    .loop
.resize:
	# Double the size of our working memory.
	.tmp    .tmp    ?+1
	.memlen .z      ?+4
	.tmp    .memlen ?+4
	.tmp    .z16    ?+1
	.memlen .tmp    ?+1
	.mem    .mem0   ?+1
	0 ? mem.realloc .mem0 .mem0 .memlen
	.z      .mem0   ?+1
	.mem    .z      ?+1
	.z      .z      ?+1
	.memrem .tmp    .mem
.done:
	.memrem .z+1    ?+1
	.memlen .memrem ?+1
	# Set [ret].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1:0 ?+1
	.ret2   .ret2   ?+1
	.ret2   .tmp    ?+1
	0 ? mem.getidx .tmp .ret2 string.struct.ptr
	0 ? mem.free   .tmp
	0 ? mem.setidx .ret2 string.struct.ptr .mem0
	0 ? mem.setidx .ret2 string.struct.len .memlen
	0       0       .arg3:3
	# Variables
	0-1 .z:0 1 2
	.z16:16
	.tmp:0
	.eol:10
	.neol:0-10
	.nchar:0
	.mem0:0
	.memrem:0
	.memlen:0
	.ret2:0

#|==============================================================================


Memory Library - v1.02

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
deegen1.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


memory.sico handles common memory management functions. If it is concatenated
with other files, it must be included last for memory allocation to work.


--------------------------------------------------------------------------------
Index


Dereferencing
mem.getargs [dst0] refs0 [dst1] refs1 ... 0
mem.get     [val] [mem]
mem.getidx  [val] [mem] [idx]
mem.set     [mem] [val]
mem.setidx  [mem] [idx] [val]

Bulk Operations
mem.zero    [dst] [len]
mem.copy    [dst] [src] [len]
mem.sort    [arr] [len] cmp

Allocation
mem.alloc   [mem] [len]
mem.realloc [ret] [mem] [len]
mem.free    [mem]
mem.alloc.verifyfree


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Supports referencing, zeroing, copying, and allocation.
1.01
     Fixed comments.
     Renamed get/set functions.
1.02
     Added mem.sort.


--------------------------------------------------------------------------------
TODO


Add mem.alloclen to return the allocated size of a block.
Replace alloc hash table with AVL tree.
	Find the smallest block that will fit an allocation.
	If there are multiple matches, choose the one with the smallest address.
Simplify mem.alloc.verify using mem.get and mem.cmp.
mem.binsearch mem len val cmp
	use fibonacci instead of powers of 2
Optimize mem.realloc. Don't use mem.zero, just mem.copy.
Optimize mem.sort to n*log(n).


|#

mem.debug: 1


#---------------------------------------------------------------------------------
# Dereferencing


mem.getargs:
	# Call  : mem.getargs.0 ? mem.getargs dst0 refs0 dst1 refs1 ... 0
	# Effect:
	#      Simplifies parsing arguments from the 0 stack.
	#      For example, when calling "0 ? SomeFunc arg1 arg2".
	#      Stops parsing arguments when dst=0.
	#      Sets [0]=0.
	#
	#      refs=0: [dst]=[0]
	#      refs=1: [dst]=[[0]]
	#      refs=2: [dst]=[[[0]]]
	#
	# Time  : 12+(18+6*refs)*args
	0       .z+2    ?+1
	.0      .z+2    ?+1
	.arg2   .arg2   ?+1
	.arg2   .0      ?+1
	.0      .z+1    ?+1
	.arg3   .arg3   ?+1
	.arg3   .0      ?+1
.argloop:
	.0      .0      ?+1
	.tmp    .arg2:0 ?+1
	# If dst=0, we're done.
	.tmp    .z      .done
	.arg2   .z-2    ?+1
	# Setup the destination address.
	.dst0   .dst0   ?+1
	.dst0   .tmp    ?+1
	.dst1   .dst1   ?+1
	.dst1   .tmp    .done+4
.done:
	0       0       ?+1
	.ref
	# Get the dereferencing depth.
	.ref    .arg3:0 ?+1
	.arg3   .z-2    ?+1
	# Get argument from original stack and dereference.
	.val    .val    ?+1
	.val    0       ?+1
	0       .z+1    ?+1
.refloop:
	.ref    .z      .ref0
	.tmp    .tmp    ?+1
	.tmp    .val:0  ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ref    .z-1    .refloop
.ref0:
	# Write dereferenced argument to the destination address.
	.val    .dst0:0 ?+1
	.z      .val    ?+1
	.dst1:0 .z      ?+1
	.tmp    .tmp    .argloop
	# Variables
	0-2 0-1 .0:.z:0 1 2
	.ref:0
	.tmp:0


mem.get:
	# Call  : 0 ? mem.get0 val mem
	# Effect: [val]=[[mem]]
	# Time  : 27
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get val.
	.val0   .arg2:2 ?+1
	.val1   .val0   ?+1
	.val2   .val0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .val1   ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	# Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	# Set [val]=[[mem]]
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.m1     .m1     ?+1
	.m1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .m1:0   ?+1
	.val0:0 .val1:0 ?+1
	.val2:0 .tmp    ?+1
	0       0       .arg4:4
	# Variables
	.off:2
	.tmp:0


mem.getidx:
	# Call  : 0 ? mem.getidx val mem idx
	# Effect: [val]=[[mem]+[idx]]
	# Time  : 33
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get val.
	.val0   .arg2:2 ?+1
	.val1   .val0   ?+1
	.val2   .val0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .val1   ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	# Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	# Get -[idx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.i0     .i0     ?+1
	.i0     .tmp    ?+1
	# Set [val]=[[mem]+[idx]]
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.tmp    .i0:0   ?+1
	.mi     .mi     ?+1
	.mi     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mi:0   ?+1
	.val0:0 .val1:0 ?+1
	.val2:0 .tmp    ?+1
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0


mem.set:
	# Call  : 0 ? mem.set mem val
	# Effect: [[mem]]=[val]
	# Time  : 27
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.m1     .m0:0   ?+1
	# Get val.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	# Set [[mem]]=[val]
	.m2     .m1     ?+1
	.m3     .m1     ?+1
	.tmp    .tmp    ?+1
	.tmp    .m2     ?+1
	.m1     .m1     ?+1
	.m1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .val0:0 ?+1
	.m1:0   .m2:0   ?+1
	.m3:0   .tmp    ?+1
	0       0       .arg4:4
	# Variables
	.off:2
	.tmp:0


mem.setidx:
	# Call  : 0 ? mem.setidx mem idx val
	# Effect: [[mem]+[idx]]=[val]
	# Time  : 33
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.mi0    .m0:0   ?+1
	# Get -[idx].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.i0     .i0     ?+1
	.i0     .tmp    ?+1
	.mi0    .i0:0   ?+1
	# Get val.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	# Set [[mem]+[idx]]=[val]
	.mi1    .mi0    ?+1
	.mi2    .mi0    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mi1    ?+1
	.mi0    .mi0    ?+1
	.mi0    .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .val0:0 ?+1
	.mi0:0  .mi1:0  ?+1
	.mi2:0  .tmp    ?+1
	0       0       .arg5:5
	# Variables
	.off:2
	.tmp:0


#---------------------------------------------------------------------------------
# Bulk Operations


mem.zero:
	# Call  : 0 ? mem.zero mem len
	# Effect: Zeroes out memory addresses in [[mem],[mem]+[len]).
	# Time  : 24+4*len
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get [len]. Return if [len]=0.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.len0   .len0   ?+1
	.len0   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .len0:0 ?+1
	.tmp    .z      .done
	.len    .tmp    ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.mem0   .mem0   ?+1
	.mem0   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mem0:0 ?+1
	# Setup the initial memory pointers.
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	# Zero loop.
.loop:
	.p0:0   .p1:0   ?+1
	.len    .z+1    .done
	.p0     .z-1    ?+1
	.p1     .z-1    .loop
.done:
	0       0       .arg4:4
	# Variables
	0-1 .len:.z:0 1 2
	.tmp:0


mem.copy:
	# Call  : 0 ? mem.copy dst src len
	# Effect: Copies data from [[src],[src]+[len]) onto [[dst],[dst]+[len]).
	# Time  : 39+9*len
	# Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	# Get [len]. Return if [len]=0.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.len0   .len0   ?+1
	.len0   .tmp    ?+1
	.nlen   .nlen   ?+1
	.nlen   .len0:0 ?+1
	.nlen   .z      .done
	# Get [src].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.s0     .s0     ?+1
	.s0     .tmp    ?+1
	# Get [dst].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.d0     .d0     ?+1
	.d0     .tmp    ?+1
	.ndst   .ndst   ?+1
	.ndst   .d0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ndst   ?+1
	# Determine our copy direction.
	.inc    .inc    ?+1
	.tmp    .s0:0   .le
	# Copy back to front.
	.len    .nlen   ?+1
	.ndst   .len    ?+1
	.ndst   .z-1    ?+1
	.inc    .z-1    .setup
.le:
	# Copy front to back. If [dst]=[src], return.
	.tmp    .z      .done
	.len    .nlen   ?+1
	.inc    .z+1    .setup
.setup:
	# Setup the data pointers.
	.src    .src    ?+1
	.src    .tmp    ?+1
	.src    .ndst   ?+1
	.tmp    .tmp    ?+1
	.tmp    .dst0   ?+1
	.ndst   .tmp    ?+1
	.dst0   .ndst   ?+1
	.dst1   .ndst   ?+1
	.dst2   .ndst   ?+1
	.tmp    .tmp    ?+1
	# Copy the data.
.loop:
	.tmp    .src:0  ?+1
	.dst0:0 .dst1:0 ?+1
	.dst2:0 .tmp    ?+1
	.len    .z+1    .done
	.dst0   .inc    ?+1
	.dst1   .inc    ?+1
	.dst2   .inc    ?+1
	.src    .inc    ?+1
	.tmp    .tmp    .loop
.done:
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.ndst:0
	.inc:0
	.len:0
	.nlen:0


mem.sort:
	# Call  : 0 ? mem.sort arr len cmp
	# Effect: Stably sorts [arr] in ascending order.
	# Time  : 12 + 20*len + (12+cmp)*len*(len-1)/2
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	0       0       ?+1
	# Get [len].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nlen   .nlen   ?+1
	.nlen   .p1:0   ?+1
	.len    .nlen   ?+1
	.len    .z+1    .ret
	# Get [arr].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.narr   .narr   ?+1
	.narr   .p0:0   ?+1
	.i0     .i0     ?+1
	.i0     .narr   ?+1
	# Get cmp.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.cmp    .cmp    ?+1
	.cmp    .tmp    ?+1
	.tmp    .tmp    .loop0+3
.loop0:
	.len    .z+1    .ret+3
	# Reset [i] to our current index.
	.i      .nlen   ?+1
	.i      .len    ?+1
	# Update array pointers to [arr]+[i].
	.narr   .z+1    ?+1
	.i0     .z-1    ?+1
	.i1     .i1     ?+1
	.i1     .narr   ?+1
	.i2     .i2     ?+1
	.i2     .narr   ?+1
	# Record [ival]=[[arr]+[i]].
	.tmp    .i0:0   ?+1
	.ival   .ival   ?+1
	.ival   .tmp    ?+1
	.pval   .pval   ?+1
	.pval   .tmp    .loop1+6
	# Sort [ival].
.loop1:
	.i2     .z+1    ?+1
	.i      .z+1    .done1+3
	.i1     .z+1    ?+1
	.tmp    .tmp    ?+1
	.tmp    .i1:0   ?+1
	.jval   .jval   ?+1
	.jval   .tmp    ?+1
	0 ? .cmp:0 .jval .ival .done1 .done1 ?+1
	.pval   .jval   ?+1
	.i2:0   .pval   ?+1
	.pval   .pval   .iset:?+1
	.pval   .tmp    .loop1
.done1:
	.i      .i      ?+1
	# Set [[arr]+[i]]=[ival].
	.pval   .ival   ?+1
	.iset   .set0   .i2
.iret:
	.iset   .set1   ?+1
	.tmp    .tmp    .loop0
.ret:
	.len    .len    ?+1
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.narr:0
	.len:0
	.nlen:0
	.i:0
	.ival:0
	.jval:0
	.pval:0
	.set0:.iset+1-.iret
	.set1:.iret-.iset-1


#|------------------------------------------------------------------------------
Allocation

The memory module must be included at the end of the program so that
mem.alloc.start can mark the beginning of unused space.


     +------------------+---------+---------+---------+---------+---------+
     | mem.alloc.start: | Buckets | Block 0 | Block 1 | Block 2 |   ...   |
     +------------------+---------+---------+---------+---------+---------+


The layout after mem.alloc.start is:


      0: [2^1, 2^2)
      1: [2^2, 2^3)
      2: [2^3, 2^4)
     ....
     62: [2^63, 2^64)
     63: Pointer to start+64
     64: Catch-all block
     65: First actual block


A free block with space for data will have links for the bucket it's in.


     +--------------------------------------------------------------------+
     |                             Free Block                             |
     +-----------+-----------+------------+------------+------------------+
     | blocknext | blockprev | bucketprev | bucketnext | unused cells ... |
     +-----------+-----------+------------+------------+------------------+


When a block becomes allocated, blockprev and blocknext will be swapped. The
rest of the cells will be used for data.


     +--------------------------------------------------------------------+
     |                          Allocated Block                           |
     +-----------+-----------+------------+------------+------------------+
     | blockprev | blocknext |   data 0   |   data 1   |       ...        |
     +-----------+-----------+------------+------------+------------------+


If blockprev&lt;blocknext, then the block is allocated. The last block will have
blocknext=mem.alloc.end.
|#


mem.error:
	# Call  : mem.error.z ? mem.error str
	# Effect: Prints str and aborts.
	# Get str.
	.msg    .z      ?+1
.loop:
	.z      .z      ?+1
	.z      .msg:2  ?+1
	.char   .char   ?+1
	.z      .char   .done
	.char   .z      ?+1
	0-2     .char   ?+1
	.msg    .z-1    .loop
.done:
	# Variables/Abort
	0-1 .z:0 .char:0


mem.alloc.init:
	# Call  : mem.alloc.init.z ? mem.alloc.init
	# Effect: An internal function that initializes the memory allocator for use. Only
	#         runs once.
	# Setup return and original 0.
	.ret    .z      ?+1
	.z      .z      ?+1
	.tmp0   0       ?+1
	0       0       ?+1
	# Modify allocation functions so mem.alloc.init only runs once.
	mem.alloc+2        .z-3 ?+1
	mem.free+2         .z-3 ?+1
	mem.realloc+2      .z-3 ?+1
	mem.alloc.verify+2 .z-3 ?+1
	# If we're debugging, make sure the first 2048 cells after the starting address
	# are 0.
	mem.debug .z    .dbgzdone
.dbgzloop:
	.zcheck .z+1    .dbgzdone
	.p0:mem.alloc.start .z .dbgzgood
	# ERROR: Alloc memory not 0
	mem.error.z ? mem.error 'E 'R 'R 'O 'R ': '  'A 'l 'l 'o 'c '  'm 'e 'm 'o 'r 'y '  'n 'o 't '  '0 10 0
.dbgzgood:
	.p0     .z-1    .dbgzloop
.dbgzdone:
	# len=end-start-65-2. Need len&gt;=2, hence end-(start+69)&gt;=0.
	.minend mem.alloc.end .hasmem
	# ERROR: Not enough memory
	mem.error.z ? mem.error 'E 'R 'R 'O 'R ': '  'N 'o 't '  'e 'n 'o 'u 'g 'h '  'm 'e 'm 'o 'r 'y 10 0
.hasmem:
	# Setup the catch-all block.
	mem.alloc.start+63 .s63 ?+1
	mem.alloc.start+64 .s64 ?+1
	# Setup a free block spanning all available memory.
	# Block next
	.z mem.alloc.end ?+1
	mem.alloc.start+65 .z ?+1
	.z      .z      ?+1
	# Block prev, leave 0.
	# Bucket pointer.
	# len=-minend+2
	.z      .minend ?+1
	.z      .z-2    ?+1
	0 ? mem.alloc.getbucket .bkt0 .z
	.z      .z      ?+1
	.bkt0:0 .bkt65  ?+1
	# Bucket prev.
	.z      .bkt0   ?+1
	.z      .z-3    ?+1
	mem.alloc.start+67 .z ?+1
	# Bucket next, leave 0.
	0       .tmp0   .ret:2
	# Variables.
	0-3 0-2 0-1 .z:0 1
	.tmp0:0
	.zcheck:2049
	.s63:0-mem.alloc.start-64
	.s64:0-1+mem.alloc.start+64+2
	.bkt65:0-mem.alloc.start-65
	.minend:mem.alloc.start+69


mem.alloc.getbucket:
	# Call  : 0 ? mem.alloc.getbucket ret len
	# Effect: [ret]=log2([len])+mem.alloc.start-1
	# This is used to figure out what bucket a given length falls in.
	# Time  : 76
	# Expect len&gt;=2.
	# Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	# Get ret.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp0   ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp0   ?+1
	# Get [len].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp0   ?+1
	.nlen   .nlen   ?+1
	.nlen   .l0:0   ?+1
	# Setup the loop counter and tree pointer.
	.i      .i0     ?+1
	.t0     .t0     ?+1
	.t0     .off+0  ?+4
.loop:
	# If len&lt;=mem[tree+i], branch left (i*2+1).
	# Otherwise, branch right (i*2+2).
	.i      .z+1    .done
	.tmp0   .tmp0   ?+1
	.tmp0   .nlen   ?+1
	.tmp0   .t0:0   ?+4
	.tmp1   .off+2  ?+4  # len&gt;tree[i]
	.tmp1   .off+1  ?+1  # len&lt;=tree[i]
	.tmp1   .t0     ?+1
	.t0     .tmp1   ?+1
	.tmp1   .tmp1   .loop
.done:
	.t0     .last   ?+1
	.t0     .ret0:0 ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .t0     ?+1
	.ret1:0 .tmp0   ?+1
	0       0       .arg4:4
	# Variables
	0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.nlen:0
	.i:0
	.i0:0-6
	.off:0-.tree 1-.tree 2-.tree
	.tree:
		0xffffffff 0xffff 0xffffffffffff 0xff 0xffffff 0xffffffffff 0xffffffffffffff
		0xf 0xfff 0xfffff 0xfffffff 0xfffffffff 0xfffffffffff 0xfffffffffffff
		0xfffffffffffffff 0x3 0x3f 0x3ff 0x3fff 0x3ffff 0x3fffff 0x3ffffff 0x3fffffff
		0x3ffffffff 0x3fffffffff 0x3ffffffffff 0x3fffffffffff 0x3ffffffffffff
		0x3fffffffffffff 0x3ffffffffffffff 0x3fffffffffffffff 0x1 0x7 0x1f 0x7f 0x1ff
		0x7ff 0x1fff 0x7fff 0x1ffff 0x7ffff 0x1fffff 0x7fffff 0x1ffffff 0x7ffffff
		0x1fffffff 0x7fffffff 0x1ffffffff 0x7ffffffff 0x1fffffffff 0x7fffffffff
		0x1ffffffffff 0x7ffffffffff 0x1fffffffffff 0x7fffffffffff 0x1ffffffffffff
		0x7ffffffffffff 0x1fffffffffffff 0x7fffffffffffff 0x1ffffffffffffff
		0x7ffffffffffffff 0x1fffffffffffffff 0x7fffffffffffffff
	.last:.last-mem.alloc.start+1


mem.alloc.verifyfree:
	# Call  : 0 ? mem.alloc.verify
	# Effect: Verifies that all blocks are free.
	mem.alloc.verify.valc mem.alloc.verify.z-1 ?+1
mem.alloc.verify:
	# Call  : 0 ? mem.alloc.verify
	# Effect: Verifies all blocks.
	# Setup return.
	.arg2 .arg2 ?+1
	mem.alloc.init.z ? mem.alloc.init
	0     .z+2  ?+1
	.arg2 0     ?+1
	0     0     ?+1
	# Verify buckets. Want to show bucket head-&gt;bktprev+3=bkt.
	.bkt0   .sbkt   ?+4
.bktloop:
	# Get the head of the current bucket.
	.bkt0   .nbkt   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt0:1 ?+1
	.tmp0   .z      .nullblock
	.tmp0   .z+2    ?+1
	.blk0   .blk0   ?+1
	.blk0   .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .blk0:0 ?+1
	# Want mem[blk+2]-bkt+3=0.
	.tmp1   .tmp1   ?+1
	.tmp1   .bkt0   ?+1
	.tmp0   .tmp1   ?+1
	.tmp0   .z+3    ?+1
	.tmp0   .z      .nullblock
	.z      .z      .errormeta
.nullblock:
	.bkt0   .lbkt   .bktloop
	# Verify catch-all.
	# Verify catch-all bucket. Want mem[start+63]=start+64.
	.tmp0   .tmp0   ?+1
	.tmp0   .catch0 ?+1
	.tmp0   mem.alloc.start+63 ?+1
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	# verify catch-all size. Want mem[start+64]=-1+(start+64+2).
	.tmp0   .tmp0   ?+1
	.tmp0   .catch1 ?+1
	.tmp0   mem.alloc.start+64 ?+1
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	# Go through each block and verify it.
	.blk1   .blk1   ?+1
	.blk1   .sblk   ?+1
	.lblk   .lblk   ?+1
	.lblk   mem.alloc.end ?+1
	.alloc  .alloc  ?+1
.blkloop:
	# If mem.alloc.end&lt;=blk, we're done.
	.tmp0   .tmp0   ?+1
	.tmp0   .lblk   ?+1
	.tmp0   .blk1   .blkdone
	0 ? mem.alloc.verifyblock .blk1
	# Get prev=mem[blk+0].
	.tmp0   .tmp0   ?+1
	.tmp0   .blk1:0 ?+1
	.prv    .prv    ?+1
	.prv    .tmp0   ?+1
	# Get next=mem[blk+1].
	.tmp1   .tmp1   ?+1
	.tmp1   .blk1   ?+1
	.tmp1   .z+1    ?+1
	.blk2   .blk2   ?+1
	.blk2   .tmp1   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .blk2:0 ?+1
	.blk1   .blk1   ?+1
	.blk1   .tmp1   ?+1
	# if prev&gt;=blk
	.alloc  .z-1    ?+1
	.prv    .blk1   .blkloop
	# The block is free. Set blk=prv.
	.alloc  .z+1    ?+1
	.blk1   .blk1   ?+1
	.blk1   .tmp0   .blkloop
.blkdone:
	# Verify blk=mem.alloc.end.
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	# If we have any allocated memory. Use valc to toggle verifying that all blocks
	# are free.
	.valc   .z     .noalloc
	.valc   .valc   ?+1
	.alloc  .z      ?+4
	.z      .z      .errorfree
.noalloc:
	# Return.
	0       0       .arg2:2
.errormeta:
	# ERROR: Corrupt memory metadata
	mem.error.z ? mem.error 'E 'R 'R 'O 'R ': '  'C 'o 'r 'r 'u 'p 't '  'm 'e 'm 'o 'r 'y '  'm 'e 't 'a 'd 'a 't 'a 10 0
.errorfree:
	# ERROR: Unfreed memory
	mem.error.z ? mem.error 'E 'R 'R 'O 'R ': '  'U 'n 'f 'r 'e 'e 'd '  'm 'e 'm 'o 'r 'y 10 0
	# Variables
	0-1 .z:0 1 2 3
	.tmp0:0
	.tmp1:0
	.sbkt:   1-mem.alloc.start # start bucket, sbkt=-1+start
	.lbkt:  61+mem.alloc.start # last bucket,  lbkt=start+(bits-3)
	.nbkt:0-62-mem.alloc.start # next bucket,  nbkt=-1-lbkt
	.catch0:0-mem.alloc.start-64
	.catch1:0-1+mem.alloc.start+64+2
	.sblk:0-65-mem.alloc.start
	.lblk:0
	.prv:0
	.alloc:0
	.valc:0


mem.alloc.verifyblock:
	# Call  : 0 ? mem.alloc.verifyblock blk
	# Effect: Verifies the metadata of [blk].
	# Setup the stack.
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	# Get [blk].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.blk0   .blk0   ?+1
	.blk0   .tmp0   ?+1
	.nblk   .nblk   ?+1
	.nblk   .blk0:0 ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	# Setup block pointers we'll use later.
	.prv0   .blk    ?+1
	.nxt0   .prv0   ?+1
	.prv3   .prv0   ?+1
	.nxt5   .prv0   ?+1
	.prv0   .prv0   ?+1
	.prv0   .nblk   ?+1
	#
	# Make sure we're not about to read out of bounds memory.
	#
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1     # [tmp1]=[end]
	.tmp1   .blk    .error  # if end&lt;=blk
	.tmp1   .z+2    .error  # if end-blk&lt;=2
	#
	# Determine if the block is free and get the previous and next blocks.
	#
	.free   .free   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prv0:0 ?+1
	.prev   .prev   ?+1
	.prev   .tmp0   ?+1     # [blkprv]=mem[blk+0]
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt0:1 ?+1
	.next   .next   ?+1
	.next   .tmp1   ?+1     # [blknxt]=mem[blk+1]
	# if prev&lt;=next, the bucket is allocated
	.prev   .next   .isallocated
	# Swap prev and next.
	.free   .z-1    ?+1
	.next   .next   ?+1
	.next   .tmp0   ?+1
	.prev   .prev   ?+1
.isallocated:
	.prev   .tmp1   ?+1
	#
	# Verify previous block's properties.
	#
	# No block should come before mem.start.
	# Only the first block should have prev=0.
	.tmp0   .tmp0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .strt65 .firstblock
	# We're past the first block. Verify blkprev!=0.
	.prev   .z      .error
	.z      .z      .firstdone
.firstblock:
	# This is the first block. Verify blk-start-65=0 and blkprev=0.
	.z+1    .tmp0   .error
	.z+1    .prev   .error
.firstdone:
	# The previous block should be at least 4 cells behind the current one.
	.tmp0   .tmp0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .prev   .error  # if [blk]&lt;=[blkprv]
	.tmp0   .z+3    .error  # if [blk]-[blkprv]&lt;=3
	# If this block is free, the previous block should be allocated. Thus
	# mem[prev+1]=block. Otherwise, either of the previous pointers could point to
	# this block.
	.prev   .z      .blkprvdone
	# Get the previous block's pointers.
	.prv1   .prev   ?+1
	.prv2   .prv1   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prev   ?+1
	.prv1   .prv1   ?+1
	.prv1   .tmp0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .prv2:1 ?+1
	.tmp1   .nblk   ?+1          # [tmp1]=-mem[prev+1]+blk
	.tmp1   .z      .blkprvdone  # if mem[prev+1]=blk, done
	# Previous block is free, error if this block is free too.
	.z+1    .free   .error
	# This block is allocated. Verify mem[prev]=blk.
	.tmp1   .tmp1   ?+1
	.tmp1   .prv1:0 ?+1
	.tmp1   .nblk   ?+1     # [tmp1]=-mem[prev+0]+blk
	.z+1    .tmp1   .error
.blkprvdone:
	#
	# Verify the next block's properties.
	#
	# The next block should be at least 4 cells ahead of the current one.
	.tmp0   .tmp0   ?+1
	.tmp0   .next   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .blk    .error  # if [blknxt]&lt;=[blk]
	.tmp1   .z+3    .error  # if [blknxt]-[blk]&lt;=3
	# Get the bucket for later.
	.tmp1   .z-1    ?+1
	0 ? mem.alloc.getbucket .bkt .tmp1
	# If this block is free, the next block should be allocated. Thus
	# mem[prev]=block. Otherwise, either of the next pointers could point to this
	# block.
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .lastblock  # if [end]&lt;=[next]
	# Get the next block's pointers.
	.nxt1   .next   ?+1
	.nxt2   .nxt1   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .next   ?+1
	.nxt1   .nxt1   ?+1
	.nxt1   .tmp0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt1:0 ?+1
	.tmp1   .nblk   ?+1          # [tmp1]=-mem[next]+blk
	.tmp1   .z      .blknxtdone  # if mem[next]=blk, done
	# Next block is free, error if this block is free too.
	.z+1    .free   .error
	# This block is allocated. Verify mem[next+1]=blk.
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt2:1 ?+1
	.tmp1   .nblk   ?+1     # [tmp1]=-mem[prev+0]+blk
	.z+1    .tmp1   .error
	.z      .z      .blknxtdone
.lastblock:
	# If the next block is past the end of memory.
	.z+1    .tmp1   .error
.blknxtdone:
	#
	# Verify the block's previous bucket block.
	#
	.free   .z      .bktdone
	# Since the block will point to another block or a header, bktprv will never be
	# 0. Verify bktprv-&gt;bktnxt=blk. Also verify both blocks are assigned to the same
	# bucket by length.
	.nprev  .nprev  ?+1
	.nprev  .prv3:2 ?+1
	.prev   .prev   ?+1
	.prev   .nprev  ?+1     # bktprv=mem[blk+2]
	.nxt3   .nxt3   ?+1
	.nxt3   .nprev  ?+1
	.nxt3   .z-3    ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nxt3:0 ?+1
	.tmp0   .nblk   ?+1     # [tmp0]=-mem[bktprv+3]+[blk]
	.z+1    .tmp0   .error  # if bktprv-&gt;bktnxt!=block
	# Verify bucket head or previous block's bucket size.
	.tmp0   .tmp0   ?+1
	.tmp0   .nprev  ?+1
	.tmp0   .strt62 .bktprvhead
	.nxt4   .nxt4   ?+1
	.nxt4   .nprev  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nxt4:0 ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .prev   ?+1
	.tmp1   .z+2    ?+1     # [tmp1]=mem[bktprv]-bktprv-2
	0 ? mem.alloc.getbucket .tmp0 .tmp1
	.bkt    .tmp0   ?+1
	.z+1    .bkt    .error  # if bucket(blk)!=bucket(prev)
	.z      .z      .bktprvdone
.bktprvhead:
	# The previous pointer is to a bucket. Verify bktprv+3=bkt.
	.bkt    .prev   ?+1
	.bkt    .z+3    ?+1
	.z+1    .bkt    .error  # if bktprv+3!=bkt
.bktprvdone:
	#
	# Verify the block's next bucket block.
	#
	# Verify bktnxt-&gt;bktprv=blk.
	.nnext  .nnext  ?+1
	.nnext  .nxt5:3 ?+1
	.nnext  .z      .bktnxtdone
	.next   .next   ?+1
	.next   .nnext  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .error  # if [end]&lt;=[bktnxt]
	.tmp1   .z+3    .error  # if [end]-[bktnxt]&lt;=3
	.prv4   .prv4   ?+1
	.prv4   .nnext  ?+1
	.prv4   .z-2    ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prv4:0 ?+1
	.tmp0   .nblk   ?+1     # [tmp0]=-mem[bktnxt+2]+blk
	.z+1    .tmp0   .error  # if mem[bktnxt+2]!=blk
.bktnxtdone:
.bktdone:
	# We're done verifying.
	.tmp0   .tmp0   .arg3:3
.error:
	0       0       mem.alloc.verify.errormeta
	# Variables
	0-3 0-2 0-1 .z:0 1 2 3
	.tmp0:0
	.tmp1:0
	.blk:0
	.nblk:0
	.free:0
	.nprev:0
	.prev:0
	.nnext:0
	.next:0
	.strt62:mem.alloc.start+62
	.strt65:mem.alloc.start+65
	.bkt:0


mem.alloc:
	# Call  : 0 ? mem.alloc mem len
	# Effect: Sets [mem] to a memory address with [len] free cells. Cells are
	# initialized to 0.
	# Time  : 1041+4*len
	.tmp0   .tmp0   ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	# Get mem.
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp0   ?+1
	# Get [len]. If [len]=0, set [mem]=0 and return.
	.nblk   .nblk   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .p0:0   ?+1
	.tmp0   .z      .ret
	.len    .len    ?+1
	.len    .tmp0   ?+1
	# [len] must be at least 2.
	.len    .z+1    ?+4
	.p1     .p1     ?+7
	.len    .z-1    ?+1
	.p1     .p1     ?+1
	# Search through the buckets until we find a block such that len&lt;=blocklen.
	.p1     .nstart ?+4
.loop:
	.p1     .z-1    ?+1
	.nblk   .nblk   ?+1
	.nblk   .p1:0   ?+1
	.nblk   .z      .loop
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	# [nbln]=-next+blk+2=-block.len
	.tmp1   .tmp1   ?+1
	.tmp1   .blk:0  ?+1
	.tmp1   .nblk   ?+1
	.tmp1   .z-2    ?+1
	.slen   .slen   ?+1
	.slen   .tmp1   ?+1
	.slen   .len    .loop
	# If this is the catch-all bucket, abort.
	.p1     .catch  ?+4
	0-1     0       ?-2
	# If there's enough slack space, split the block.
	# split=blk+2+len, want next-split&gt;=4
	# slen=next-blk-2-(len-1)=next-split+1
	# Need slen-1&gt;=4 or tmp0&gt;=5
	.slen   .z+4    .nosplit0
	.len    .z-3    ?+1
	.s0     .blk    ?+1
	.s0     .len    ?+1
	.len    .z-4    ?+1
	.slen   .z-1    .didsplit0
.nosplit0:
	# We're not splitting, so we want len=next-blk.
	# tmp1=-next+blk+2
	.len    .len    ?+1
	.len    .tmp1   ?+1
	.len    .z-2    ?+1
	.slen   .slen   ?+1
.didsplit0:
	.b00    .blk    ?+1
	.b01    .b00    ?+1
	.b10    .b00    ?+1
	.b11    .b00    ?+1
	.b2     .b00    ?+1
	.b3     .b00    ?+1
	.b00    .b00    ?+1
	.b00    .nblk   ?+1
	# Get the block neighbors.
	.nnext  .nnext  ?+1
	.nnext  .b00:0  ?+1
	.nprev  .nprev  ?+1
	.nprev  .b10:1  ?+1
	# Remove from bucket. We already know bktprev.next=bktnext.prev=blk.
	# Get bktprev
	.tmp0   .tmp0   ?+1
	.tmp0   .b2:2   ?+1
	.n1     .tmp0   ?+1
	# Get bktnext
	.tmp1   .tmp1   ?+1
	.tmp1   .b3:3   ?+1
	.n2     .tmp1   ?+1
	# Set bktprev.next
	.n1     .z-3    ?+1
	.tmp1   .nblk   ?+1
	.n1:0   .tmp1   ?+1
	.n1     .n1     ?+1
	# Set bktnext.prev
	.n2     .z      .nonext0
	.n2     .z-2    ?+1
	.tmp0   .nblk   ?+1
	.n2:0   .tmp0   ?+1
	.n2     .n2     ?+1
.nonext0:
	0 ? mem.zero .blk .len
	# Setup the split block.
	.slen   .z      .nosplit1
	.s1     .s0     ?+1
	.s2     .s0     ?+1
	.s3     .s0     ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .s1     ?+1
	.tmp0   .z-1    ?+1
	.s0     .s0     ?+1
	.s0     .tmp0   ?+1
	# Set the split block's neighbors.
	.s0:0   .nnext  ?+1
	.s1:1   .nblk   ?+1
	# Add split block to a free bucket.
	0 ? mem.alloc.getbucket .bkt .slen
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt:0  ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .bkt    ?+1
	# mem[blk+3]=next
	.s3:3   .tmp0   ?+1
	# next=mem[bkt]
	# if next: mem[next+2]=blk. Note mem[next+2]=bkt-3.
	.nxt2   .nxt2   ?+1
	.nxt2   .z-2    ?+1
	.tmp0   .z      .nonext1
	.bkt    .s3     ?+1
	.nxt2   .tmp0   ?+1
	.nxt2:0 .bkt    ?+1
.nonext1:
	# mem[bkt]=split
	.n4     .n4     ?+1
	.n4     .tmp1   ?+1
	.nxt2   .s2     ?+1
	.n4:0   .nxt2   ?+1
	# mem[split+2]=bkt-3
	.tmp1   .z-3    ?+1
	.s2:2   .tmp1   ?+1
	# Change the next block's prev pointer to split.
	.n3     .nnext  ?+1
	.n3     mem.alloc.end ?+1
	.n3     .z      .nonext2
	.n3     .n3     ?+1
	.n3     .nnext  ?+1
	.blk    .s0     ?+1
	.n3:0   .blk    ?+1
	.n3     .n3     ?+1
.nonext2:
	# Change the block's next pointer to split.
	.nnext  .nnext  ?+1
	.nnext  .s0     ?+1
.nosplit1:
	# Swap block next and prev.
	.b01:0  .nprev  ?+1
	.b11:1  .nnext  ?+1
	# Shift -blk to the data section.
	.nblk   .z+2    ?+1
.ret:
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .nblk   ?+1
	0       0       .arg4:4
	# Variables
	0-4 0-3 0-2 0-1 .z:0 1 2 3 4
	.tmp0:0
	.tmp1:0
	.nblk:0
	.len:0
	.nstart:0-mem.alloc.start
	.catch:mem.alloc.start+62
	.slen:0
	.nnext:0
	.nprev:0


mem.realloc:
	# Call  : 0 ? mem.alloc ret mem len
	# Effect: Sets [ret] to a memory address with [len] free cells. Copies contents
	# of [mem] and frees it. Set uninitialized cells to 0.
	.tmp    .tmp    ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	0       0       ?+1
	# Get [ret].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	# Get [len].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.nlen   .nlen   ?+1
	.nlen   .l0:0   ?+1
	.len    .len    ?+1
	.len    .nlen   ?+1
	# Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.mem    .mem    ?+1
	.mlen   .mlen   ?+1
	# Get the length of mem's block.
	.tmp    .z      .memnull
	.mem    .tmp    ?+1
	.mem    .z+1    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mem:0  ?+1
	.mlen   .tmp    ?+1
	.mem    .z-1    ?+1
	.mlen   .mem    ?+1
	# Set mlen to min(mlen,len).
	.mlen   .len    ?+4
	.mlen   .mlen   ?+1
	.mlen   .nlen   ?+1
.memnull:
	# Allocate the new block and copy data.
	0 ? mem.alloc .ret .len
	0 ? mem.copy .ret .mem .mlen
	0 ? mem.free .mem
	# Set ret.
	.tmp    .tmp    ?+1
	.ret    .ret0:0 ?+1
	.tmp    .ret    ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	# Variables
	0-1 .z:0 1 2
	.tmp:0
	.mlen:0
	.nlen:0
	.len:0
	.ret:0


mem.free:
	# Call  : 0 ? mem.free mem
	# Effect: Frees the memory block at [mem] that was allocated by mem.alloc. If
	# [mem]=0, do nothing.
	# Time  : 387+6*len, no debug: 210
	.tmp0   .arg2   ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp0   .z-2    ?+1
	0       .tmp0   ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	# Get [blk]. Note [mem]=[blk]+2. If [mem]=0, we're done.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.b0     .b0     ?+1
	.b0     .tmp0   ?+1
	.nblk   .nblk   ?+1
	.nblk   .b0:0   ?+1
	.nblk   .z      .done
	.nblk   .z-2    ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	# Verify [blk] is a valid block and we're not double freeing. Randomize the data
	# section to help prevent using the memory after freeing.
	mem.debug .z .dbgdone0
	0 ? mem.alloc.verifyblock .blk
	mem.alloc.verifyblock.free .z .dbgdone0
	# ERROR: Double free
	mem.error.z ? mem.error 'E 'R 'R 'O 'R ': '  'D 'o 'u 'b 'l 'e '  'f 'r 'e 'e 10 0
.dbgdone0:
	# prev=mem[blk+0]
	.nprev  .nprev  ?+1
	.nprev  .blk:0  ?+1
	.prev   .prev   ?+1
	.prev   .nprev  ?+1
	# next=mem[blk+1]
	.p1     .p1     ?+1
	.p1     .nblk   ?+1
	.p1     .z-1    ?+1
	.nnext  .nnext  ?+1
	.nnext  .p1:0   ?+1
	.next   .next   ?+1
	.next   .nnext  ?+1
	# Randomize the entire block to prevent using after freeing.
	mem.debug .z .dbgdone1
	.rand   0-5     ?+1
	# Get the block start and length.
	.dbg0   .dbg0   ?+1
	.dbg0   .nblk   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nnext  ?+1
	.tmp0   .dbg0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .blk    ?+4
.dbgrandloop:
	.tmp0   .z+1    .dbgdone1
	.dbg0:0 .rand   ?+1
	.tmp1   .rand   ?+1
	.rand   .tmp1   ?+7
	.rand   .rcon0  ?+1
	.dbg0   .z-1    .dbgrandloop
	.rand   .rcon1  ?+1
	.dbg0   .z-1    .dbgrandloop
	# Random variables.
	.rand: 0xdb38ab4d4d3b3ece
	.rcon0:0x1e8352fef1e4be80
	.rcon1:0xf5819f19ab244199
.dbgdone1:
	# If the next block is free, unlink and merge it. This needs to occur before prev.
	# if next&lt;end
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .nextdone
	# Setup next block pointers.
	.n0     .next   ?+1
	.n1     .n0     ?+1
	.n2     .n0     ?+1
	.n3     .n0     ?+1
	.n0     .n0     ?+1
	.n0     .nnext  ?+1
	# if mem[next]==blk, skip
	.tmp0   .tmp0   ?+1
	.tmp0   .n1:0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .z      .nextdone
	# next.prev=mem[next+2]
	.tmp0   .tmp0   ?+1
	.tmp0   .n2:2   ?+1
	.prv0   .prv0   ?+1
	.prv0   .tmp0   ?+1
	# next.next=mem[next+3]
	.tmp1   .tmp1   ?+1
	.tmp1   .n3:3   ?+1
	.nxt0   .nxt0   ?+1
	.nxt0   .tmp1   ?+1
	# mem[next.prev+3]=next.next. Note mem[next.prev+3]=next.
	.prv0   .z-3    ?+1
	.tmp1   .nnext  ?+1
	.prv0:0 .tmp1   ?+1
	# if next.next: mem[next.next+2]=next.prev. Note mem[next.next+2]=next.
	.nxt0   .z      ?+10
	.nxt0   .z-2    ?+1
	.tmp0   .nnext  ?+1
	.nxt0:0 .tmp0   ?+1
	# next=mem[next]
	.nnext  .nnext  ?+1
	.nnext  .n0:0   ?+1
	.next   .next   ?+1
	.next   .nnext  ?+1
.nextdone:
	# If the previous block is free, unlink and merge it.
	# if prev!=0
	.prev   .z      .prevdone
	# Setup previous block pointers.
	.r0     .prev   ?+1
	.r1     .r0     ?+1
	.r2     .r0     ?+1
	.r3     .r0     ?+1
	.r0     .r0     ?+1
	.r0     .nprev  ?+1
	# if mem[prev]==blk
	.tmp0   .tmp0   ?+1
	.tmp0   .r0:0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .z      ?+4
	.tmp0   .tmp0   .prevdone
	# blk=prev
	.nblk   .nblk   ?+1
	.nblk   .prev   ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	# prev.prev=mem[prev+2]
	.tmp0   .tmp0   ?+1
	.tmp0   .r2:2   ?+1
	.prv1   .prv1   ?+1
	.prv1   .tmp0   ?+1
	# prev.next=mem[prev+3]
	.tmp1   .tmp1   ?+1
	.tmp1   .r3:3   ?+1
	.nxt1   .nxt1   ?+1
	.nxt1   .tmp1   ?+1
	# mem[prev.prev+3]=prev.next. Note mem[prev.prev+3]=prev.
	.prv1   .z-3    ?+1
	.tmp1   .nprev  ?+1
	.prv1:0 .tmp1   ?+1
	# if prev.next: mem[prev.next+2]=prev.prev. Note mem[prev.next+2]=prev.
	.nxt1   .z      ?+10
	.nxt1   .z-2    ?+1
	.tmp0   .nprev  ?+1
	.nxt1:0 .tmp0   ?+1
	# prev=mem[prev+1]
	.nprev  .nprev  ?+1
	.nprev  .r1:1   ?+1
.prevdone:
	# If next&lt;end, set mem[next]=blk.
	mem.alloc.end .next .nonext0
	.p22    .next   ?+1
	.p23    .p22    ?+1
	.p24    .p22    ?+1
	.p22    .p22    ?+1
	.p22    .nnext  ?+1
	.p22:0  .p23:0  ?+1
	.p24:0  .nblk   ?+1
.nonext0:
	mem.alloc.end .nnext ?+1
	# Setup block pointers.
	.b1     .blk    ?+1
	.b2     .b1     ?+1
	.b3     .b1     ?+1
	.b4     .b1     ?+1
	.b5     .b1     ?+1
	.b6     .b1     ?+1
	.b7     .b1     ?+1
	.b8     .b1     ?+1
	.b9     .b1     ?+1
	.b10    .b1     ?+1
	.b11    .b1     ?+1
	.b12    .b1     ?+1
	.b1     .b1     ?+1
	.b1     .nblk   ?+1
	# mem[blk+0]=next
	.b1:0   .b2:0   ?+1
	.b3:0   .nnext  ?+1
	# mem[blk+1]=prev
	.b4:1   .b5:1   ?+1
	.b6:1   .nprev  ?+1
	# Add block to a free bucket.
	# len=next-blk-2
	# bkt=self.getbucket(len)
	.next   .blk    ?+1
	.next   .z+2    ?+1
	0 ? mem.alloc.getbucket .bkt .next
	.nnext  .nnext  ?+1
	.nnext  .bkt:0  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt    ?+1
	# mem[blk+3]=next
	.b7:3   .b8:3   ?+1
	.b9:3   .nnext  ?+1
	# next=mem[bkt]
	# if next: mem[next+2]=blk. Note mem[next+2]=bkt-3.
	.nxt2   .nxt2   ?+1
	.nxt2   .z-2    ?+1
	.nnext  .z      .nonext1
	.bkt    .b7     ?+1
	.nxt2   .nnext  ?+1
	.nxt2:0 .bkt    ?+1
.nonext1:
	# mem[bkt]=blk
	.p31    .p31    ?+1
	.p31    .tmp0   ?+1
	.nxt2   .b10    ?+1
	.p31:0  .nxt2   ?+1
	# mem[blk+2]=bkt-3
	.tmp0   .z-3    ?+1
	.b10:2  .b11:2  ?+1
	.b12:2  .tmp0   ?+1
.done:
	.tmp0   .tmp0   .arg3:3
	# Variables
	0-3 0-2 0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.nblk:0
	.nprev:0
	.prev:0
	.nnext:0
	.next:0


mem.alloc.end: 0-32
mem.alloc.start:

# The end of the universe and the start of unused memory. Nothing should come
# after this label.


</textarea>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="footer">Created on 9 Apr 2020 - Modified on 28 Jun 2023<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's General Site</a></div>
</body>
</html>
