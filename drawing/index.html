<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>SVG Rasterizing from Scratch</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script src="../style/style.js"></script>
	<script>function DEMO(f) {return import("./demo.js").then(f);}</script>
</head>
<body>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's General Site</a></div>
<div id="content">


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Drawing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h1>Drawing</h1>
<p><a href="#" onclick="DEMO(M=>M.PerformanceTest())">Performance test</a></p>
<div id="perfdisplay" style="display:none">
<p>These tests capture the relative difference of aliased, path-based, and
cached raster methods.</p>
<p><a href="#" onclick="DEMO(M=>M.PerformanceCopy())">&#9112; Copy results</a>
</p>
<div class="consoleblock" id="perftable"></div>
<canvas id="perfcanvas"></canvas>
</div>
<p><a href="./drawing.js">drawing.js</a> is a small (~50kb) graphics library
I'm developing for use in simple 2D demos. Everything from polygons, to circles,
to letters are composed of just 2 things: lines and bezier curves.</p>
<canvas id="drawdemo" width=1000 height=400
style="background:#000000;width:80%;"></canvas>
<script>DEMO(M=>new M.DrawDemo("drawdemo"));</script>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Preprocessing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h1>Preprocessing</h1>
<p>Even though every shape can be easily composed of lines and curves (known as
a path), converting them to actual pixels on a screen requires quite a bit of
preprocessing and math.</p>
<svg version="1.1" viewBox="0 0 1000 450" class="diagram"
style="background:#000000">
	<text x=300 y=50 style="font-size:30px" class="center">Path</text>
	<g transform="translate(0,50)">
	<g class="highstroke">
		<line x1=367 y1=79 x2=372 y2=84 />
		<line x1=380 y1=98 x2=380 y2=118 />
		<line x1=380 y1=118 x2=380 y2=166 />
		<line x1=342 y1=193 x2=296 y2=193 />
		<line x1=296 y1=193 x2=277 y2=193 />
		<line x1=266 y1=190 x2=251 y2=183 />
		<line x1=251 y1=183 x2=246 y2=189 />
		<line x1=241 y1=197 x2=241 y2=207 />
		<line x1=241 y1=207 x2=241 y2=218 />
		<line x1=253 y1=225 x2=268 y2=226 />
		<line x1=333 y1=228 x2=372 y2=230 />
		<line x1=401 y1=250 x2=401 y2=283 />
		<line x1=401 y1=283 x2=401 y2=327 />
		<line x1=360 y1=355 x2=294 y2=355 />
		<line x1=294 y1=355 x2=242 y2=355 />
		<line x1=197 y1=340 x2=197 y2=299 />
		<line x1=197 y1=299 x2=197 y2=273 />
		<line x1=213 y1=259 x2=227 y2=248 />
		<line x1=227 y1=248 x2=220 y2=245 />
		<line x1=205 y1=234 x2=205 y2=213 />
		<line x1=205 y1=213 x2=205 y2=196 />
		<line x1=215 y1=181 x2=228 y2=166 />
		<line x1=228 y1=166 x2=216 y2=152 />
		<line x1=211 y1=140 x2=211 y2=120 />
		<line x1=211 y1=120 x2=211 y2=76 />
		<line x1=244 y1=45 x2=295 y2=45 />
		<line x1=295 y1=45 x2=309 y2=45 />
		<line x1=316 y1=46 x2=323 y2=48 />
		<line x1=295 y1=165 x2=323 y2=165 />
		<line x1=342 y1=144 x2=342 y2=119 />
		<line x1=342 y1=119 x2=342 y2=98 />
		<line x1=329 y1=72 x2=295 y2=72 />
		<line x1=295 y1=72 x2=277 y2=72 />
		<line x1=249 y1=84 x2=249 y2=119 />
		<line x1=249 y1=119 x2=249 y2=156 />
		<line x1=279 y1=165 x2=295 y2=165 />
		<line x1=261 y1=258 x2=251 y2=266 />
		<line x1=237 y1=275 x2=237 y2=295 />
		<line x1=237 y1=295 x2=237 y2=317 />
		<line x1=267 y1=325 x2=298 y2=325 />
		<line x1=298 y1=325 x2=344 y2=324 />
		<line x1=361 y1=304 x2=361 y2=287 />
		<line x1=361 y1=287 x2=360 y2=268 />
		<line x1=343 y1=261 x2=319 y2=260 />
	</g>
	<path d="M 402 48 L 402 79 L 367 79 C 372 84 380 98 380 118 C 380 166 342
	193 296 193 C 277 193 266 190 251 183 C 246 189 241 197 241 207 C 241 218
	253 225 268 226 L 333 228 C 372 230 401 250 401 283 C 401 327 360 355 294
	355 C 242 355 197 340 197 299 C 197 273 213 259 227 248 C 220 245 205 234
	205 213 C 205 196 215 181 228 166 C 216 152 211 140 211 120 C 211 76 244 45
	295 45 C 309 45 316 46 323 48 Z M 295 165 C 323 165 342 144 342 119 C 342
	98 329 72 295 72 C 277 72 249 84 249 119 C 249 156 279 165 295 165 M 261
	258 C 251 266 237 275 237 295 C 237 317 267 325 298 325 C 344 324 361 304
	361 287 C 360 268 343 261 319 260 Z" fill="none" class="highstroke"/>
	<g class="highstroke highfill">
		<circle cx=402 cy=48 r=3 />
		<circle cx=402 cy=79 r=3 />
		<circle cx=367 cy=79 r=3 />
		<circle cx=372 cy=84 r=3 />
		<circle cx=380 cy=98 r=3 />
		<circle cx=380 cy=118 r=3 />
		<circle cx=380 cy=166 r=3 />
		<circle cx=342 cy=193 r=3 />
		<circle cx=296 cy=193 r=3 />
		<circle cx=277 cy=193 r=3 />
		<circle cx=266 cy=190 r=3 />
		<circle cx=251 cy=183 r=3 />
		<circle cx=246 cy=189 r=3 />
		<circle cx=241 cy=197 r=3 />
		<circle cx=241 cy=207 r=3 />
		<circle cx=241 cy=218 r=3 />
		<circle cx=253 cy=225 r=3 />
		<circle cx=268 cy=226 r=3 />
		<circle cx=333 cy=228 r=3 />
		<circle cx=372 cy=230 r=3 />
		<circle cx=401 cy=250 r=3 />
		<circle cx=401 cy=283 r=3 />
		<circle cx=401 cy=327 r=3 />
		<circle cx=360 cy=355 r=3 />
		<circle cx=294 cy=355 r=3 />
		<circle cx=242 cy=355 r=3 />
		<circle cx=197 cy=340 r=3 />
		<circle cx=197 cy=299 r=3 />
		<circle cx=197 cy=273 r=3 />
		<circle cx=213 cy=259 r=3 />
		<circle cx=227 cy=248 r=3 />
		<circle cx=220 cy=245 r=3 />
		<circle cx=205 cy=234 r=3 />
		<circle cx=205 cy=213 r=3 />
		<circle cx=205 cy=196 r=3 />
		<circle cx=215 cy=181 r=3 />
		<circle cx=228 cy=166 r=3 />
		<circle cx=216 cy=152 r=3 />
		<circle cx=211 cy=140 r=3 />
		<circle cx=211 cy=120 r=3 />
		<circle cx=211 cy=76 r=3 />
		<circle cx=244 cy=45 r=3 />
		<circle cx=295 cy=45 r=3 />
		<circle cx=309 cy=45 r=3 />
		<circle cx=316 cy=46 r=3 />
		<circle cx=323 cy=48 r=3 />
		<circle cx=295 cy=165 r=3 />
		<circle cx=323 cy=165 r=3 />
		<circle cx=342 cy=144 r=3 />
		<circle cx=342 cy=119 r=3 />
		<circle cx=342 cy=98 r=3 />
		<circle cx=329 cy=72 r=3 />
		<circle cx=295 cy=72 r=3 />
		<circle cx=277 cy=72 r=3 />
		<circle cx=249 cy=84 r=3 />
		<circle cx=249 cy=119 r=3 />
		<circle cx=249 cy=156 r=3 />
		<circle cx=279 cy=165 r=3 />
		<circle cx=295 cy=165 r=3 />
		<circle cx=261 cy=258 r=3 />
		<circle cx=251 cy=266 r=3 />
		<circle cx=237 cy=275 r=3 />
		<circle cx=237 cy=295 r=3 />
		<circle cx=237 cy=317 r=3 />
		<circle cx=267 cy=325 r=3 />
		<circle cx=298 cy=325 r=3 />
		<circle cx=344 cy=324 r=3 />
		<circle cx=361 cy=304 r=3 />
		<circle cx=361 cy=287 r=3 />
		<circle cx=360 cy=268 r=3 />
		<circle cx=343 cy=261 r=3 />
		<circle cx=319 cy=260 r=3 />
	</g>
	</g>
	<text x=700 y=50 style="font-size:30px" class="center">Result</text>
	<path d="M 802 48 L 802 79 L 767 79 C 772 84 780 98 780 118 C 780 166 742
	193 696 193 C 677 193 666 190 651 183 C 646 189 641 197 641 207 C 641 218
	653 225 668 226 L 733 228 C 772 230 801 250 801 283 C 801 327 760 355 694
	355 C 642 355 597 340 597 299 C 597 273 613 259 627 248 C 620 245 605 234
	605 213 C 605 196 615 181 628 166 C 616 152 611 140 611 120 C 611 76 644 45
	695 45 C 709 45 716 46 723 48 Z M 695 165 C 723 165 742 144 742 119 C 742
	98 729 72 695 72 C 677 72 649 84 649 119 C 649 156 679 165 695 165 M 661
	258 C 651 266 637 275 637 295 C 637 317 667 325 698 325 C 744 324 761 304
	761 287 C 760 268 743 261 719 260 Z" class="forefill" stroke="none"
	transform="translate(0,50)"/>
</svg>
<h2>AABB-OBB Overlap</h2>
<p>The fastest raster algorithm is one that doesn't draw anything, so our first
step when drawing a path is an
<a href="https://en.wikipedia.org/wiki/Minimum_bounding_box">AABB-OBB</a>
overlap test. For this, we draw a box around our path and then apply our
transforms to it. If the transformed box doesn't overlap the image, then we can
skip drawing the path entirely.</p>
<canvas id="obbcanvas" width=500 height=400 style="width:45%"></canvas>
<script>DEMO(M=>new M.OBBDemo("obbcanvas"));</script>
<p>My algorithm below performs this test in constant time and with no divisions.
I'm guessing I'm not the first to come up with it but, when doing research,
everyone else was doing much more complicated polygon overlap tests like
<a href="https://en.wikipedia.org/wiki/Hyperplane_separation_theorem">SAT</a>.
</p>
<div class="codeblock langjs" style="height:20rem">function img_path_collide(img_aabb,path_aabb,trans) {
	// Transform the path AABB to an OBB.
	// new_x = x*matxx + y*matxy + matx
	// new_y = x*matyx + y*matyy + maty
	let matxx=trans.mat[0],matxy=trans.mat[1],matx=trans.vec[0];
	let matyx=trans.mat[2],matyy=trans.mat[3],maty=trans.vec[1];
	let imgx=img_aabb.minx,imgy=img_aabb.miny;
	let imgw=img_aabb.maxx-imgx,imgh=img_aabb.maxy-imgy;
	// Define the transformed bounding box.
	let bx=path_aabb.minx,by=path_aabb.miny;
	let bndx=bx*matxx+by*matxy+matx-imgx;
	let bndy=bx*matyx+by*matyy+maty-imgy;
	bx=path_aabb.maxx-bx;by=path_aabb.maxy-by;
	let bndxx=bx*matxx,bndxy=bx*matyx;
	let bndyx=by*matxy,bndyy=by*matyy;
	// Test if the image AABB has a separating axis.
	let minx=bndx-imgw,maxx=bndx;
	if (bndxx&lt;0) {minx+=bndxx;} else {maxx+=bndxx;}
	if (bndyx&lt;0) {minx+=bndyx;} else {maxx+=bndyx;}
	if (!(minx&lt;0 &amp;&amp; 0&lt;maxx)) {return false;}
	let miny=bndy-imgh,maxy=bndy;
	if (bndxy&lt;0) {miny+=bndxy;} else {maxy+=bndxy;}
	if (bndyy&lt;0) {miny+=bndyy;} else {maxy+=bndyy;}
	if (!(miny&lt;0 &amp;&amp; 0&lt;maxy)) {return false;}
	// Test if the path OBB has a separating axis.
	let cross=bndxx*bndyy-bndxy*bndyx;
	minx=bndy*bndxx-bndx*bndxy;maxx=minx;
	bndxx*=imgh;bndxy*=imgw;
	if (cross&lt;0) {minx+=cross;} else {maxx+=cross;}
	if (bndxx&lt;0) {maxx-=bndxx;} else {minx-=bndxx;}
	if (bndxy&lt;0) {minx+=bndxy;} else {maxx+=bndxy;}
	if (!(minx&lt;0 &amp;&amp; 0&lt;maxx)) {return false;}
	miny=bndy*bndyx-bndx*bndyy;maxy=miny;
	bndyx*=imgh;bndyy*=imgw;
	if (cross&lt;0) {maxy-=cross;} else {miny-=cross;}
	if (bndyx&lt;0) {maxy-=bndyx;} else {miny-=bndyx;}
	if (bndyy&lt;0) {miny+=bndyy;} else {maxy+=bndyy;}
	if (!(miny&lt;0 &amp;&amp; 0&lt;maxy)) {return false;}
	return true;
}</div>
<h2>Curve Segmenting</h2>
<p>The cubic bezier curves we use are represented as cubic polynomials. This
makes determining what pixels they overlap computationally expensive. Instead,
the curves are decomposed into lines immediately before rasterization. This
conversion ends up being faster and simpler than working with the equation
directly.</p>
<div class="codeblock langjs">// The cubic bezier equation.
v = 1 - u;
p = p0*u*u*u + p1*u*u*v + p2*u*v*v + p3*v*v*v;</div>
<p>We want to minimize the number of lines approximating the curve, but also be
accurate. To do this, we take the line between the first and last points
(<i>p0</i> and <i>p3</i>) and measure the distance to the control points
(<i>p1</i> and <i>p2</i>). If the distance is too great, we split the curve in
half and try again with the two subcurves. It looks like this in action:</p>
<canvas id="curvecanvas" width=400 height=220 style="width:50%"></canvas>
<script>DEMO(M=>new M.CurveDemo("curvecanvas"));</script>
<p>When we're done, we draw the lines between <i>p0</i> and <i>p3</i> for all of
the subcurves.</p>
<p>Notice that the curvier parts get subdivided more. The distance measurements
need to be structured carefully to handle curves that are linear or have
degenerate coordinates, but it's not terribly difficult. This is how drawing.js
does it:</p>
<div class="codeblock langjs" style="height:20rem">// Test if both control points are close to the line p0->p3.
// Clamp to ends and filter degenerates.
let dx=p3x-p0x,dy=p3y-p0y,den=dx*dx+dy*dy;
let lx,ly,u;
// p1
lx=p1x-p0x;
ly=p1y-p0y;
u=dx*lx+dy*ly;
u=u>0?(u&lt;den?u/den:1):0;
lx-=dx*u;
ly-=dy*u;
let d1=lx*lx+ly*ly;
// p2
lx=p2x-p0x;
ly=p2y-p0y;
u=dx*lx+dy*ly;
u=u>0?(u&lt;den?u/den:1):0;
lx-=dx*u;
ly-=dy*u;
let d2=lx*lx+ly*ly;
// Compare distances
d1=(d1&gt;d2 || !(d1===d1))?d1:d2;
if (!(d1&gt;CURVE_MAX_DIST &amp;&amp; d1&lt;Infinity)) {
	// Done
	continue;
}
// Continue splitting
</div>
<p>Also, similar to <a href="https://en.wikipedia.org/wiki/Level_of_detail_(computer_graphics)">LOD</a>,
we can stop dividing parts of the curve outside of the image.</p>
<h2>Inside-Outside</h2>
<p>Paths may be created in clockwise or counter-clockwise order. Even if
they're created in a specific order, a transform can change it. This causes a
problem when calculating areas later, as the areas can become negative.</p>
<svg version="1.1" viewBox="0 0 750 420" class="diagram"
style="background:#000000;width:60%">
	<g transform="translate(180,180)" style="font-size:22px" class="center">
		<path d="M 0 -100 L 100 0 0 100 -100 0 Z" class="highfill"
		stroke="none"/>
		<path d="M -1 0 C -1 -0.551915 -0.551915 -1 0 -1 C 0.551915 -1 1
		-0.551915 1 0 L 1.32 0 L 0.9 0.57 L 0.48 0 L 0.8 0 C 0.8 -0.441532
		0.441532 -0.8 0 -0.8 C -0.441532 -0.8 -0.8 -0.441532 -0.8 0 Z"
		class="forefill" stroke=none transform="scale(40,40)"/>
		<text x=0 y=-120>0</text>
		<text x=120 y=0>1</text>
		<text x=0 y=120>2</text>
		<text x=-120 y=0>3</text>
		<text x=0 y=180 style="font-size:30px">area &gt; 0</text>
	</g>
	<g transform="translate(560,180)" style="font-size:22px" class="center">
		<path d="M 0 -100 L 100 0 0 100 -100 0 Z" class="highfill"
		stroke="none"/>
		<path d="M -1 0 C -1 -0.551915 -0.551915 -1 0 -1 C 0.551915 -1 1
		-0.551915 1 0 L 1.32 0 L 0.9 0.57 L 0.48 0 L 0.8 0 C 0.8 -0.441532
		0.441532 -0.8 0 -0.8 C -0.441532 -0.8 -0.8 -0.441532 -0.8 0 Z"
		class="forefill" stroke=none transform="scale(-40,40)"/>
		<text x=0 y=-120>0</text>
		<text x=120 y=0>3</text>
		<text x=0 y=120>2</text>
		<text x=-120 y=0>1</text>
		<text x=0 y=180 style="font-size:30px">area &lt; 0</text>
	</g>
</svg>
<p>To handle this, we simply calculate the signed area of the entire path after
transforming. If the total area is negative, then we just negate all of the area
calculations later.</p>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Lines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h1>Lines</h1>
<p>Now that the path has been turned into lines, we are going to fill the path
by looking at the signed area to the right of each line. There are other ways or
we could choose to find the area, but this is the one I settled on.</p>
<p>Due to how the math works out, the direction of the lines will cause half of
them to have negative area. This combination of positive and negative areas is
what determines how much to fill each pixel.</p>
<svg version="1.1" viewBox="0 0 400 400" class="diagram"
style="background:#000000;width:40%">
	<g transform="translate(200,200)" style="font-size:22px" class="center">
		<!--<path d="M 0 -100 L 300 -100 300 100 0 100 Z" class="dimfill"
		stroke="none"/>-->
		<path d="M 0 -100 L 100 0 0 100 -100 0 Z" class="highfill forestroke"
		stroke-width="2px"/>
		<text x=-85 y=  0>+</text>
		<text x=-65 y= 20>+</text>
		<text x=-45 y= 40>+</text>
		<text x=-25 y= 60>+</text>
		<text x= -5 y= 80>+</text>
		<text x=-65 y=-20>+</text>
		<text x=-45 y=-40>+</text>
		<text x=-25 y=-60>+</text>
		<text x= -5 y=-80>+</text>
		<text x=115 y=  0>-</text>
		<text x= 95 y= 20>-</text>
		<text x= 75 y= 40>-</text>
		<text x= 55 y= 60>-</text>
		<text x= 35 y= 80>-</text>
		<text x= 95 y=-20>-</text>
		<text x= 75 y=-40>-</text>
		<text x= 55 y=-60>-</text>
		<text x= 35 y=-80>-</text>
	</g>
</svg>
<h2>Strides</h2>
<p>A stride is the core concept that drawing.js's filling function is built
around. The idea is that along a row of pixels, we only need to look at the
first and last pixels of the line to be able to fill every other pixel.</p>
<svg version="1.1" viewBox="0 0 1000 195" class="diagram"
style="background:#000000;">
	<path d="M 212.5 143.5 L 799.0 51.5 H 960 V 143.5 Z"
	class="highfill" stroke="none"/>
	<path d="M 212.5 143.5 L 799.0 51.5"
	class="forestroke" fill="none" stroke-width="2px"/>
	<circle cx=212.5 cy=143.5 r=3 class="forefill" stroke="none"/>
	<circle cx=799.0 cy= 51.5 r=3 class="forefill" stroke="none"/>
	<path d="M 40 40 L 960 40 960 155 40 155 Z
	         h 115 v 115 h 115 v -115 h 115 v 115 h 115 v -115
	         h 115 v 115 h 115 v -115 h 115 v 115"
	class="dimstroke" fill="none" stroke-width="2px"/>
	<g class="center">
		<text x=212.5 y=180>+.02</text>
		<text x=327.5 y=180>+.13</text>
		<text x=442.5 y=180>+.15</text>
		<text x=557.5 y=180>+.15</text>
		<text x=672.5 y=180>+.15</text>
		<text x=787.5 y=180>+.14</text>
		<text x=902.5 y=180>+.03</text>
		<text x=212.5 y=20>first</text>
		<text x=327.5 y=20>first+1</text>
		<text x=442.5 y=20>mid</text>
		<text x=557.5 y=20>mid</text>
		<text x=672.5 y=20>mid</text>
		<text x=787.5 y=20>last</text>
		<text x=902.5 y=20>last+1</text>
	</g>
</svg>
<p>No matter how long the line is, the mid sections always increase the area by
<i>2*slope</i> of the line. It's only at the first and last pixels that this
differs. This gives us an easy form to calculate the running area of the line:
let <i>areadx1</i> be <i>2*slope</i>, and let <i>areadx2</i> be any
single-instance pixel changes.</p>
<div class="codeblock langjs">// Calculate area, areadx1, areadx2 at (x,y). Then:
for (;x&lt;width &amp;&amp; area&gt;0;x++) {
	drawpixel(x,y,color,area);
	area+=areadx1+areadx2;
	areadx2=0;
}
</div>
<p>If we have multiple lines, then we just add on to these constants as we
process them.</p>
<h2>Scheduling</h2>
<p>A typical path will get broken down into several hundred small lines, and
checking if every line overlaps a pixel will be extremely slow. Luckily there's
an easy way to track which lines are next.</p>
<p>For each line, drawing.js will track the first pixel of the line in each row
and add it to a
<a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a>, which is
only a <i>log2(n)</i> operation. We can then look at the top of the heap to see
which line to process next.</p>
<p>Once we hit a line's first pixel in a row, we just modify <i>area</i>,
<i>areadx1</i>, and <i>areadx2</i> and then ignore the line until its last pixel
in the row.</p>
<h2>Large Numbers</h2>
<p>This wouldn't normally need a section, but it's a problem I ran into after
development and took a bit to figure out.</p>
<p>If a line spanned multiple rows, the equations to calculate the left and
right-most pixel coordinates on that row looked something like this:</p>
<div class="codeblock langjs">let dx=x1-x0,dy=y1-y0;
if (y1&gt;1) {x1+=((1-y1)/dy)*dx;y1=1;}
if (y0&lt;0) {x0+=((0-y0)/dy)*dx;y0=0;}
</div>
<p>This worked perfectly well for almost all coordinates, but if the line
coordinates were very large (close to floating point saturation) this could
happen:</p>
<img src="./fillpath_large_coords.png">
<p>The exact problem is intricate, but basically the start and end pixels
(<i>x0</i> and <i>x1</i>) would be calculated improperly and prevent the
algorithm from setting the area to 0.</p>
<p>The fix ended up being to base all of the coordinate calculations around one
fixed point on the row. It's less accurate, but because everything is less
accurate together, it ends up looking better. It has the bonus of being simpler
too:</p>
<div class="codeblock langjs">let dxy=dx/dy;
let y0x=x0-y0*dxy;
if (y1&gt;1) {y1=1;x1=y0x+dxy;}
if (y0&lt;0) {y0=0;x0=y0x;}
</div>
<p>These same problems can occur when dividing by small numbers - usually when
calculating areas or calculating where a line crosses a pixel boundary. It took
me 8 versions to find formulas that were both stable and efficient.</p>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Blending ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h1>Blending</h1>
<p>At this point we have a color and an area between 0 and 1, and the question
is how to blend it with a background pixel. For this we'll be using
<a href="https://en.wikipedia.org/wiki/Alpha_compositing">alpha compositing</a>.</p>
<svg version="1.1" viewBox="0 0 1000 195" class="diagram"
style="background:#000000;">
	<rect x= 40 y=40 width=920 height=115 class="highfill" stroke="none"/>
	<rect x= 40 y=40 width=115 height=115 fill="rgb(0,0,0,1.00)" stroke="none"/>
	<rect x=155 y=40 width=115 height=115 fill="rgb(0,0,0,0.98)" stroke="none"/>
	<rect x=270 y=40 width=115 height=115 fill="rgb(0,0,0,0.84)" stroke="none"/>
	<rect x=385 y=40 width=115 height=115 fill="rgb(0,0,0,0.69)" stroke="none"/>
	<rect x=500 y=40 width=115 height=115 fill="rgb(0,0,0,0.53)" stroke="none"/>
	<rect x=615 y=40 width=115 height=115 fill="rgb(0,0,0,0.37)" stroke="none"/>
	<rect x=730 y=40 width=115 height=115 fill="rgb(0,0,0,0.23)" stroke="none"/>
	<rect x=845 y=40 width=115 height=115 fill="rgb(0,0,0,0.20)" stroke="none"/>
	<path d="M 212.5 143.5 L 799.0 51.5"
	class="forestroke" fill="none" stroke-width="2px"/>
	<circle cx=212.5 cy=143.5 r=3 class="forefill" stroke="none"/>
	<circle cx=799.0 cy= 51.5 r=3 class="forefill" stroke="none"/>
	<path d="M 40 40 L 960 40 960 155 40 155 Z
	         h 115 v 115 h 115 v -115 h 115 v 115 h 115 v -115
	         h 115 v 115 h 115 v -115 h 115 v 115"
	class="dimstroke" fill="none" stroke-width="2px"/>
	<g class="center">
		<text x= 97.5 y=180>area =</text>
		<text x=212.5 y=180>.02</text>
		<text x=327.5 y=180>.16</text>
		<text x=442.5 y=180>.31</text>
		<text x=557.5 y=180>.47</text>
		<text x=672.5 y=180>.63</text>
		<text x=787.5 y=180>.77</text>
		<text x=902.5 y=180>.80</text>
	</g>
</svg>
<p>The typical compositing equations look like this:</p>
<div class="codeblock langjs">// sa = source alpha (area)
// da = dest alpha
a = da + ( 1-da)*sa
r = dr + (sr-dr)*sa/a
g = dg + (sg-dg)*sa/a
b = db + (sb-db)*sa/a
</div>
<p>This is bad news since it involves 3 multiplies and several int/float
conversions for every single pixel. Luckily, the image RGBA values will usually
be stored as a 32 bit integer. With some bit twiddling hacks we can calculate
the RGBA values simultaneously and composite several times faster:</p>
<div class="codeblock langjs">// Precalc alpha constants
let ashift=24;
let amask=(255&lt;&lt;ashift)&gt;&gt;&gt;0;
let maskl=(0x00ff00ff&amp;~amask)&gt;&gt;&gt;0;
let maskh=(0xff00ff00&amp;~amask)&gt;&gt;&gt;0;

// Precalc color constants
let coll=(PATH_FILL_COLOR&amp;maskl)&gt;&gt;&gt;0;
let colh=(PATH_FILL_COLOR&amp;maskh)&gt;&gt;&gt;0;
let col8=colh&gt;&gt;&gt;8;

// For each pixel:
let sa =area;
let dst=imgdata[i];
let da =(dst&gt;&gt;&gt;ashift)&255;
let a  =sa*255+(1-sa)*da;
let mul=256.49-(sa/a)*65280;
imgdata[i]=(a&lt;&lt;ashift)
	|(((Math.imul((dst&amp;0x00ff00ff)-coll,mul)&gt;&gt;&gt;8)+coll)&amp;maskl)
	|((Math.imul(((dst&gt;&gt;&gt;8)&amp;0x00ff00ff)-col8,mul)+colh)&amp;maskh);
</div>
<p>I've tried other versions that involve a satanic mix between floating
and integer values, but this has remained the fastest version so far.</p>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Notes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h1>Notes</h1>
<p>Getting SVG rendering working has been a long time coming for me. Previously
I had written several functions to draw specific anti-aliased shapes, which
amounted to about 300kb across different versions and optimizations.
<a href="./drawing.js">drawing.js</a> comes out to only 50kb while doing way
more, so I'm very happy with it.</p>
<p>One thing I didn't mention was my webassembly attempts. After a lot of trial
and error, I found that WASM could only get me a ~30% speed improvement at the
cost of a really complicated rasterizing function. One thing I've never seen
mentioned with WASM is just how much of a pain dealing with the sandboxed memory
can be, as I still had to have the JS present as a fallback.</p>
<p>An honorable mention goes to yqnn for his
<a href="https://yqnn.github.io/svg-path-editor">editor</a>. It's a very
straightforward web-based SVG editor, and I've gone back to it several
times for my own designs.</p>


<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
</div><div id="footer">Created on 21 Jan 2024 - Modified on 01 Jan 2026<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's General Site</a></div>
</body>
</html>
